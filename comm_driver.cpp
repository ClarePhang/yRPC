/* comm_driver.cpp
 * DO NOT EDIT THIS FILE.
 * Date  : 2017-11-09
 * Author: zhangqiyin/Konishi
 * Email : zhangqiyin@hangsheng.com.cn
 */

#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <sys/un.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

//#include <signal.h>

#include "comm_driver.h"

volatile SocketMethod CommDriver::socket_method = NOSOCKET;

CommDriver::CommDriver()
{
    init_flag = false;
    timing_check = NULL;
    comm_base    = NULL;
    accept_base  = NULL;
    listener     = NULL;
    comm_thread_id = 0;
    accept_thread_id = 0;
}

CommDriver::~CommDriver()
{
    init_flag = false;
    timing_check = NULL;
    comm_base    = NULL;
    accept_base  = NULL;
    listener     = NULL;    
    comm_thread_id = 0;
    accept_thread_id = 0;
}

void CommDriver::showVersion(void)
{
    const char **a = event_get_supported_methods();
    printf("CommDriver : System supported methods:\n");
    for(int i = 0; a[i] != NULL; i++)
        printf("  [%s]\n",a[i]);
    // use method:   notice
    // version
}

int CommDriver::createServer(const char *server, unsigned int port)
{
    int result = -1;
    struct sockaddr_un su_addr;
    struct sockaddr_in si_addr;

    if(0 == port)
    {
        unlink(server);
        result = initSockaddr(su_addr, server);
    }
    else
        result = initSockaddr(si_addr, server, port);
    if(result < 0)
        goto CREATE_FAILED;

    if(0 == port)
        result = initEventBase(listenerCallback, (struct sockaddr *)&su_addr, sizeof(su_addr));
    else
        result = initEventBase(listenerCallback, (struct sockaddr *)&si_addr, sizeof(si_addr));
    if(result < 0)
        goto CREATE_FAILED;

    if(createThread() < 0)
        goto CREATE_FAILED;

    if(0 == port)
        socket_method = LOCALSOCKET;
    else
        socket_method = TCPSOCKET;
    return 0;

CREATE_FAILED:
    destroyThread();
    deinitEventBase();
    return -1;
}

void CommDriver::destroyServer(void)
{
    destroyThread();
    deinitEventBase();
}

void *CommDriver::connectServer(const char *server, unsigned int port)
{
    int ret = -1;
    void *result = NULL;
    struct sockaddr_un su_addr;
    struct sockaddr_in si_addr;

    if(0 == port)
        ret = initSockaddr(su_addr, server);
    else
        ret = initSockaddr(si_addr, server, port);
    if(ret < 0)
        return result;

    if(0 == port)
        result = startConnect((struct sockaddr *)&su_addr,sizeof(su_addr));
    else
        result = startConnect((struct sockaddr *)&si_addr,sizeof(si_addr));

    printf("bev = %p\n",result);
    return result;
}

void CommDriver::disconnectServer(void *connect)
{
    struct bufferevent *bev = (struct bufferevent *)connect;
    if(bev)
        bufferevent_free(bev);
}

/* for test  notice */
int CommDriver::sendData(const void *server, const void *data, size_t size)
{
    struct bufferevent * server_ptr = (struct bufferevent *)server;
    
    if(server_ptr)
        return bufferevent_write(server_ptr, data, size);

    return -1;
}

int CommDriver::createThread(void)
{
//    int kill_comm = -1, kill_accept = -1;
    
    if(pthread_create(&comm_thread_id, NULL, commEventThread, comm_base) != 0)
	{
		printf("CommDriver : pthread_create failed, errno:%d,error:%s.\n", errno, strerror(errno));
		return -1;
	}
    if(pthread_create(&accept_thread_id, NULL, acceptEventThread, accept_base) != 0)
	{
		printf("CommDriver : pthread_create failed, errno:%d,error:%s.\n", errno, strerror(errno));
		return -1;
	}
/*
    //wait thead running
    while(true)
    {
//        #include <signal.h>
        int pthread_kill(pthread_t thread, int sig);
        usleep(2*1000);
        kill_comm = pthread_kill(comm_thread_id, 0);
        kill_accept = pthread_kill(accept_thread_id, 0);
        if((ESRCH != kill_comm) && (EINVAL != kill_comm) &&
           (ESRCH != kill_accept) && (EINVAL != kill_accept))
           break;
        else
            printf("Thread has not running.\n");
    }
*/
    return 0;
}

void CommDriver::destroyThread(void)
{
    if(accept_thread_id != 0)
    {
        event_base_loopexit(accept_base, NULL);
        pthread_join(accept_thread_id, NULL);
        accept_thread_id = 0;
    }
    if(comm_thread_id != 0)
    {
        event_base_loopexit(comm_base, NULL);
        pthread_join(comm_thread_id, NULL);
        comm_thread_id = 0;
    }
}

/*
 * para: s_addr can be a sockaddr_in or sockaddr_un, s_len is the length of it.
 */
int CommDriver::initEventBase(evconnlistener_cb listener_cb, struct sockaddr *s_addr, size_t s_len)
{
    // if env set, then open debug   notice
    event_enable_debug_mode();
    event_enable_debug_logging(0);

    evthread_use_pthreads();  //enable threads

    comm_base = event_base_new();
    if(!comm_base)
    {
        printf("CommDriver : new communication_event_base failed!\n");
        goto INIT_EVENT_FAILED;
    }
    
    accept_base = event_base_new();
    if(!accept_base)
    {
        printf("CommDriver : new accept_event_base failed!\n");
        goto INIT_EVENT_FAILED;
    }
    
    evthread_make_base_notifiable(comm_base);
    evthread_make_base_notifiable(accept_base);

    listener = evconnlistener_new_bind(accept_base, listener_cb,(void *)comm_base,
        LEV_OPT_REUSEABLE|LEV_OPT_REUSEABLE_PORT|LEV_OPT_THREADSAFE|BEV_OPT_CLOSE_ON_FREE,
        -1, s_addr, s_len);
    if(!listener)
    {
        printf("CommDriver : new event_listener failed!\n");
        goto INIT_EVENT_FAILED;
    }

    if(initTimingCheckCallback() < 0)
        goto INIT_EVENT_FAILED;
    
    return 0;
    
INIT_EVENT_FAILED:
    deinitTimingCheckCallback();
    deinitEventBase();
    return -1;
}

void CommDriver::deinitEventBase(void)
{
    if(listener)
    {
        evconnlistener_free(listener);
        listener = NULL;
    }
    if(comm_base)
    {
        event_base_free(comm_base);
        comm_base = NULL;
    }
    if(accept_base)
    {
        event_base_free(accept_base);
        accept_base = NULL;
    }
}

int CommDriver::initTimingCheckCallback(void)
{
    struct timeval tv = {DEFAULT_CHECK_CYCLE, 0};

    // if env set, then change default check cycle  notice
    // tv.tv_second = ;

    timing_check = (struct event *)malloc(sizeof(struct event));
    if(!timing_check)
    {
        printf("CommDriver : new timint check event failed!\n");
        return -1;
    }
    if(evtimer_assign(timing_check, comm_base, timingCheckCallback, timing_check) < 0)
    {
        printf("CommDriver : new timint check event failed!\n");
        goto INIT_TIMING_FAILED;
    }
    if(evtimer_add(timing_check, &tv) < 0)
    {
        printf("CommDriver : add timing check handler to comm_base failed!\n");
        goto INIT_TIMING_FAILED;
    }

    init_flag = true;
    return 0;
    
INIT_TIMING_FAILED:
    deinitTimingCheckCallback();
    return -1;
}

void CommDriver::deinitTimingCheckCallback(void)
{
    if(init_flag)
    {
        init_flag = false;
        evtimer_del(timing_check);
    }
    if(timing_check)
    {
        free(timing_check);
        timing_check = NULL;
    }
}

void *CommDriver::startConnect(struct sockaddr *s_addr, size_t s_len)
{
    int result = -1;
    struct bufferevent *bev = NULL;
    struct timeval read_timeout = {5, 0};
    struct timeval write_timeout = {4, 0};

    bev = bufferevent_socket_new(comm_base, -1, BEV_OPT_THREADSAFE | BEV_OPT_CLOSE_ON_FREE);
    if(!bev)
    {
        printf("Client : new bufferevent_socket failed!\n");
        goto CONNECT_FAILED;
    }

    bufferevent_setcb(bev, readCallback, writeCallback, eventCallback, bev);
    bufferevent_set_timeouts(bev, &read_timeout, &write_timeout);
    result = bufferevent_socket_connect(bev, s_addr, s_len);
    if( -1 == result)
    {
        printf("Connect failed!\n");
        goto CONNECT_FAILED;
    }

    bufferevent_enable(bev , EV_READ|EV_WRITE);

    return (void *)bev;

CONNECT_FAILED:
    return NULL;
}

void *CommDriver::commEventThread(void *arg)
{
    struct event_base *base = (struct event_base *)arg;
    
    printf("CommDriver : communication event-loop id:%lu\n",pthread_self());
    printf("CommDriver : communication event-base addr = 0x%p\n",base);
    
    event_base_dispatch(base);
    
    printf("CommDriver : communication event-loop exit.\n");
    pthread_exit(NULL);
}

void *CommDriver::acceptEventThread(void *arg)
{
    struct event_base *base = (struct event_base *)arg;
    
    printf("CommDriver : accept event-loop id:%lu\n",pthread_self());
    printf("CommDriver : accept event-base addr = 0x%p\n",base);
    
    event_base_dispatch(base);
    
    printf("CommDriver : accept event-loop exit.\n");
    pthread_exit(NULL);
}

void CommDriver::timingCheckCallback(evutil_socket_t fd, short event, void *arg)
{
    struct timeval tv = {DEFAULT_CHECK_CYCLE,0};
    struct event *base = (struct event *)arg;
    
    printf("\nCommDriver : check network:%p\n",arg);
    evtimer_add(base, &tv);
}

void CommDriver::listenerCallback(struct evconnlistener *listener, evutil_socket_t fd,
                                   struct sockaddr *sa, int socklen, void *user_data)
{
    struct bufferevent *bev = NULL;
    struct event_base *base = (struct event_base *)user_data;

    switch(socket_method)
    {
        case TCPSOCKET:
            printf("CommDriver : New connecting from %s:%d\n",
                   inet_ntoa(((sockaddr_in *)sa)->sin_addr),
                   ntohs(((sockaddr_in *)sa)->sin_port));
            break;
        case LOCALSOCKET:
            printf("CommDriver : New connecting from :%s\n", 
                ((sockaddr_un *)sa)->sun_path);
            break;
        default:
            printf("CommDriver : New connecting error, not socket!\n");
            return ;
    }

    bev = bufferevent_socket_new(base, fd, LEV_OPT_THREADSAFE | BEV_OPT_CLOSE_ON_FREE);
    if(!bev)
    {
        printf("CommDriver : Could not create new bufferevent!\n");
        return ;
    }

    // set communication timeout if needed
    struct timeval tv_read = {15, 0}, tv_write = {13, 0};
    bufferevent_set_timeouts(bev, &tv_read,&tv_write);

    //BEV_OPT_THREADSAFE support
    int ret = bufferevent_enable(bev, BEV_OPT_THREADSAFE);
    if(ret < 0)
    {
        printf("CommDriver : enable bufferevent BEV_OPT_THREADSAFE failed!\n");
        bufferevent_free(bev);
        return ;
    }

    //printf("CommDriver : new bufferevent addr :%p\n",bev);
    // set readcb, writecb and errcb
    bufferevent_setcb(bev, readCallback, writeCallback, eventCallback, NULL);
    bufferevent_enable(bev, EV_READ | EV_WRITE);
    
}

void CommDriver::readCallback(struct bufferevent *bev, void *user_data)
{
    struct evbuffer *input = bufferevent_get_input(bev);
    size_t sz = evbuffer_get_length(input);
    
    printf("\nCommDriver : readCallback thread: %lu\n",pthread_self());
    printf("CommDriver : bufferevent addr :%p\n",bev);

    if(sz > 0)
    {
        // here use c++ virtual function   notice
        char msg[1024] = {'\0'};
        int readlen = 1024 > sz ? sz : 1024;
        bufferevent_read(bev, msg, readlen);
        printf("CommDriver : recv %d, %s .\n",readlen, msg);
    }
}

void CommDriver::writeCallback(struct bufferevent *bev, void *user_data)
{
    struct evbuffer *output = bufferevent_get_output(bev);

    //printf("\nCommDriver : writeCallback thread: %lu\n",pthread_self());
    //printf("CommDriver : bufferevent addr :%p\n",bev);
    
    if(evbuffer_get_length(output) == 0)
    {
        //printf("CommDriver : Output evbuffer is flushed.\n");
        return;
    }
}

void CommDriver::eventCallback(struct bufferevent *bev, short events, void *user_data)
{
    printf("\nCommDriver : eventCallback thread: %lu\n",pthread_self());
    printf("CommDriver : bufferevent addr :%p\n",bev);

    if(events & BEV_EVENT_EOF)
    {
        printf("CommDriver : Connection closed!\n");
    }
    else if(events & BEV_EVENT_CONNECTED)
    {
        printf("CommDriver : New connection finishi!\n");
        return ;  // normal condition
    }
    else if(events & BEV_EVENT_ERROR)
    {
        printf("CommDriver : Got error on the connection:%s\n",strerror(errno));
        //printf("CommDriver : Got error on the connection:%s\n",evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
    }
    else if(events & BEV_EVENT_TIMEOUT)
    {
        if(events & BEV_EVENT_READING)  // read timeout
        {
            printf("CommDriver : read data from %p timeout!\n", bev);
        }
        else if(events & BEV_EVENT_WRITING)
        {
            printf("CommDriver : write data from %p timeout!\n", bev);
        }
        // if timeout, event will disable read/write,so:
        if(!(bufferevent_get_enabled(bev) & EV_READ))
        {
            printf("CommDriver : reenable %p readable.\n",bev);
            bufferevent_enable(bev, EV_READ);
        }
        if(!(bufferevent_get_enabled(bev) & EV_WRITE))
        {
            printf("CommDriver : reenable %p writeable.\n",bev);
            bufferevent_enable(bev, EV_WRITE);
        }
        return ;  // normal condition
    }
    else
    {
        printf("CommDriver : Got unknown error on the connection:%s\n",strerror(errno));
        //printf("CommDriver : Got unknown error on the connection:%s\n",evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
    }

    if(bev)
        bufferevent_free(bev);
}

