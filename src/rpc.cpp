/* rpc.cpp
 * DO NOT EDIT THIS FILE.
 * Date  : 2017-11-22
 * Author: zhangqiyin/Konishi
 * Email : zhangqiyin@hangsheng.com.cn
 */
#include <string>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

#include <sys/un.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

#include "rpc.h"
#include "message.h"
#include "bodydata.h"
#include "rpc_proxy.h"

using namespace std;

RPCHash HSAERPC::func_hash;
unsigned int HSAERPC::frame_id = 1;
ThreadPool HSAERPC::rpc_threadpool;

HSAERPC::HSAERPC()
{
    process.clear();
    proxy_hash.clear();
}

HSAERPC::~HSAERPC()
{
    process.clear();
    proxy_hash.clear();
}

int HSAERPC::setProcessName(const char *process)
{
    if(process[0] == '.')
        this->process = &process[2];
    else
        this->process = process;

    return 0;
}

int HSAERPC::setConfigPath(const string &network, const string &module)
{
    int ret = -1;
    ret = network_config.setConfigProfile(network);
    if(ret == 0)
        ret = module_config.setConfigProfile(module);
    return ret;
}

int HSAERPC::addService(const char *server, void (*func)(void *arg))
{
    string key(server);
    if(func_hash.find(key) != NULL)
    {
        printf("RPC : %s server has been exsit!\n", server);
        return -1;
    }
    return func_hash.insert(key, (void *)func);
}

int HSAERPC::setResponseMsg(MessageStr &msg, void *response, size_t len)
{
    string process;
    BodyData bodydata;
    MessageStr *msgptr = NULL;

    bodydata.getApplyBodyData(msg.body_data, NULL, NULL);
    this->module_config.referModule(bodydata.module, process);
    
    if(process == this->process) // module in current process
    {
        ProxyInterface *proxy_impl = (ProxyInterface *)proxy_hash.find(msg.message_id);
        if(proxy_impl == NULL)
        {
            return -1;
        }

        mallocApplyResponseMsg(&msgptr, &msg->timesp, msg->message_id);
        bodydata.setApplyBodyData(&msg->body_data, response, len);
        setBodyData(msg, msg->body_data, bodydata.size());
        
        proxy_impl->setResponseMsg(msgptr);
        proxy_impl->wakeup();
    }
    // if on current process, then get frame, proxyStruct, and wakeup thread
    return 0;
}

int HSAERPC::proxyCall(const string &module, const string &func, void *send, size_t slen, void **recv, size_t &rlen)
{
    int result = -1;
    string mprocess;
    SocketStruct addr;
    struct timespec tp;
    BodyData bodydata;
    struct timeval tv = {5, 0};
    unsigned int frame = 0;
    MessageStr *msg = NULL;
    ProxyInterface proxy_impl;
    ServerFunction func_ptr = NULL;
    
    // 1. first refer Module-Process table
    result = module_config.referModule(module, mprocess);
    if(result < 0)
    {
        printf("RPC : current system does't has %s module, please check!\n", module.c_str());
        return -1;
    }

    // init attr , cond , mutex
    result = proxy_impl.init();
    if(result < 0)
    {
        printf("RPC : init proxy interface failed!\n");
        return -1;
    }
    
    frame = getFrameID();
    tp.tv_sec = 5;
    tp.tv_nsec = 0;
    bodydata.setModule(module);
    bodydata.setFunction(func);
    mallocApplyRequestMsg(&msg, &tp, frame);
    bodydata.setApplyBodyData(&msg->body_data, send, slen);
    setBodyData(msg, msg->body_data, bodydata.size());
    
    if(mprocess == this->process) // module in current process
    {
        func_ptr = (ServerFunction)func_hash.find(func);
        if(func_ptr == NULL)
        {
            printf("RPC : %s module does't has %s function, please check!\n", module.c_str(), func.c_str());
            return -1;
        }
        
        // add thread work
        result = rpc_threadpool.addWork(LowPriority, func_ptr, (void *)msg);
        if(result < 0)
            return -1;
    }
    else  // module in other process
    {
        result = network_config.getNetworkConfig(mprocess, addr);
        if(result < 0)
        {
            printf("RPC : %s process does't not have ip-addr config, please check!\n", process.c_str());
            return -1;
        }

        // add sender work and wait
        
    }

    proxy_hash.insert(frame,(void *)&proxy_impl);
    if(proxy_impl.wait(tv))
        printf("ProxyWait timeout!\n");
    else
        printf("ProxyCall OK!\n");
    proxy_hash.remove(frame);
    
    if(recv)
    {
//        rlen = ;
        *recv = proxy_impl.getResponseMsg();
    }
    
    return 0;
}

int HSAERPC::start(void)
{
    int result = -1;
    SocketStruct socket_str;
    struct timeval tv = {10,0};
    struct sockaddr_un u_addr;
    struct sockaddr_in s_addr;
    
    // 1.find local socket config
    result = network_config.getNetworkConfig(this->process, socket_str);
    if(result < 0)
    {
        printf("RPC : could not find %s process configuration!\n", process.c_str());
        return -1;
    }

    // 2.set communicate timeout
    rpc_comm_base.setCommTime(tv);
    
    // 3.create socket base thread from
    if(socket_str.port == 0) // use localsocket
    {
        unlink(socket_str.ipaddr.c_str());
        socket_base.initSockaddr(u_addr, socket_str.ipaddr.c_str());
        rpc_comm_base.create(event_handler, (struct sockaddr *)&u_addr, sizeof(u_addr));
    }
    else
    {
        socket_base.initSockaddr(s_addr, socket_str.ipaddr.c_str(), socket_str.port);
        rpc_comm_base.create(event_handler, (struct sockaddr *)&s_addr, sizeof(s_addr));
    }

    // 4.create threadpool
    rpc_threadpool.create(5, 3, 50);
    
    return 0;
}

int HSAERPC::RunUntilAskedToQuit(void)
{
    // 1.register signal handler
    //while(1)
        sleep(1);
    
    return 0;
}

unsigned int HSAERPC::getFrameID(void)
{
    return frame_id++;
}

int HSAERPC::recvData(const void *data, size_t data_len)
{
    string name((const char *)data, data_len);
    ServerFunction func;
    printf("\n\nstart to analyze data.\n");
    func = (ServerFunction) func_hash.find(name);
    if(func)
    {
        rpc_threadpool.addWork(LowPriority, func, (void *)data);
    }
    else
    {
        printf("could not find %s function\n", name.c_str());
    }
    
    return 0;
}

int HSAERPC::event_handler(unsigned int type, void *fd_ptr, void *data, size_t data_len)
{
    switch(type)
    {
        case RPCEventRecv:
            printf("Recv: RPCEventRecv, %p\n", fd_ptr);
            printf("CommDriver : recv %lu, %s .\n",data_len, (char *)data);
            recvData(data, 6);
            break;
            
        case RPCEventSend:
            printf("test: RPCEventSend\n");
            break;
            
        case RPCEventConnect:
            printf("test: RPCEventConnect,%p\n", fd_ptr);
            break;
            
        case RPCEventDisconnect:
            printf("test: RPCEventDisconnect,%p\n",fd_ptr);
            break;
            
        case RPCEventCheck:
            printf("test: RPCEventCheck\n");
            break;
            
        case RPCEventRTimeout:
            printf("test: RPCEventRTimeout, %p\n",fd_ptr);
            break;
            
        case RPCEventSTimeout:
            printf("test: RPCEventSTimeout\n");
            break;
            
        default:
            break;
    }
    
    return 0;
}

