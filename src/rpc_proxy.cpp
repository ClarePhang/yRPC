/* rpc_proxy.cpp
 * DO NOT EDIT THIS FILE.
 * Date  : 2017-11-20
 * Author: Konishi
 * Email : konishi5202@163.com
 */
#include "rpc_proxy.h"

#define tp_tvaddtp(tv, tp, ttp)					\
	do {								\
		(ttp)->tv_sec = (tv)->tv_sec + (tp)->tv_sec;		\
		(ttp)->tv_nsec = ((tv)->tv_usec * 1000)+ (tp)->tv_nsec;       \
		if ((ttp)->tv_nsec >= 1000000000) {			\
			(ttp)->tv_sec++;				\
			(ttp)->tv_nsec -= 1000000000;			\
		}							\
	} while (0)

RPCProxy::RPCProxy()
{
    request = NULL;
    response = NULL;
}

RPCProxy::~RPCProxy()
{
    request = NULL;
    response = NULL;
}

int RPCProxy::init(void)
{
    if(pthread_attr_init(&attr) != 0)
        return -1;

    if(pthread_cond_init(&cond, NULL) != 0)
    {
        pthread_attr_destroy(&attr);
        return -1;
    }
    
    if(pthread_mutex_init(&mutex, NULL) != 0)
    {
        pthread_attr_destroy(&attr);
        pthread_cond_destroy(&cond);
        return -1;
    }

    return 0;
}

void RPCProxy::destroy(void)
{
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
    pthread_attr_destroy(&attr);
}

int RPCProxy::wait(struct timeval &tv)
{
    int result = -1;
    
    struct timespec tp;
    pthread_mutex_lock(&mutex);
    if((tv.tv_sec == 0) && (tv.tv_usec == 0))
        result = pthread_cond_wait(&cond, &mutex);
    else
    {
        clock_gettime(CLOCK_REALTIME,&tp);
        tp_tvaddtp(&tv, &tp, &tp);
        result = pthread_cond_timedwait(&cond, &mutex, &tp);
    }
    pthread_mutex_unlock(&mutex);

    return result;
}

void RPCProxy::wakeup(void)
{
    pthread_mutex_lock(&mutex);
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&mutex);
}

void RPCProxy::setRequestMsg(void *msg)
{
    request = msg;
}

void *RPCProxy::getRequestMsg(void)
{
    return request;
}

void RPCProxy::setResponseMsg(void *msg)
{
    response = msg;
}

void *RPCProxy::getResponseMsg(void)
{
    return response;
}

