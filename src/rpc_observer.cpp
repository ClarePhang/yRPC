/* rpc_observe.h
 * DO NOT EDIT THIS FILE.
 * Date  : 2018-01-22
 * Author: Konishi
 * Email : konishi5202@163.com
 */
#include <stdio.h>
#include "rpc_observer.h"

#define K_DEBUG   printf
#define K_INFO    printf
#define K_WARN    printf
#define K_ERROR   printf

ObserverHash::ObserverHash()
{
    m_observer_map.clear();
}

ObserverHash::~ObserverHash()
{
    m_observer_map.clear();
}

void ObserverHash::print(void)
{
    K_INFO("Observer Table:\n");
    for(m_it = m_observer_map.begin(); m_it != m_observer_map.end(); m_it++)
        K_INFO("       %s\n", m_it->first.c_str());
}

int ObserverHash::size(void)
{
    return m_observer_map.size();
}

int ObserverHash::size(const string &key)
{
    m_it = m_observer_map.find(key);
    if(m_it == m_observer_map.end())
        return 0;
    return m_it->second->size();
}

void ObserverHash::clear(void)
{
    for(m_it = m_observer_map.begin(); m_it != m_observer_map.end(); m_it++)
    {
        m_it->second->clear();
        delete (m_it->second);
    }
    m_observer_map.clear();
}

bool ObserverHash::empty(void)
{
    return m_observer_map.empty();
}

bool ObserverHash::empty(const string &key)
{
    m_it = m_observer_map.find(key);
    if(m_it == m_observer_map.end())
        return true;
    return m_it->second->empty();
}

OBSERVER_LIST_PTR ObserverHash::find(const string &key)
{
    m_it = m_observer_map.find(key);
    return ((m_it == m_observer_map.end()) ? NULL : m_it->second);
}

void ObserverHash::remove(const string &key)
{
    m_it = m_observer_map.find(key);
    if(m_it != m_observer_map.end())
    {
        m_it->second->clear();
        delete(m_it->second);
        m_observer_map.erase(m_it);
    }
}

int ObserverHash::insert(const string &key)
{
    m_it = m_observer_map.find(key);
    if(m_it != m_observer_map.end())  // exsit
        return 1;
    
    OBSERVER_LIST_PTR it = new OBSERVER_LIST;
    if(NULL == it)
    {
        K_ERROR("new observer list memory failed!\n");
        return -1;
    }
    it->clear();
    m_observer_map[key] = it;
    return 0;
}

void ObserverHash::remove(const string &key, void *fdp)
{
    m_it = m_observer_map.find(key);
    if(m_it == m_observer_map.end())  // not exsit
        return ;
    m_it->second->remove(fdp);
}

int ObserverHash::insert(const string &key, void *fdp)
{
    m_it = m_observer_map.find(key);
    if(m_it == m_observer_map.end())  // not exsit
    {
        K_ERROR("insert observer failed, %s is not exsit!\n", key.c_str());
        return -1;
    }

    m_it->second->push_back(fdp);
    return 0;
}

void ObserverHash::remove(void *fdp)
{
    for(m_it = m_observer_map.begin(); m_it != m_observer_map.end(); m_it++)
        m_it->second->remove(fdp);
}

