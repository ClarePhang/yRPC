/* rpc_core.cpp
 * DO NOT EDIT THIS FILE.
 * Date  : 2017-11-22
 * Author: Konishi
 * Email : konishi5202@163.com
 */
#include <time.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <assert.h>
#include <unistd.h>
#include <pthread.h>
#include <execinfo.h>

#include <sys/un.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

#include "message.h"
#include "rpc_core.h"
#include "rpc_proxy.h"
#include "socket_base.h"

using namespace std;

#define K_DEBUG   printf
#define K_INFO    printf
#define K_WARN    printf
#define K_ERROR   printf

/* Error Code List */
#define RPCSUCCESS              0x0000
#define RPCNOSPECIFYSERVICE     0x0001   // no service
#define RPCNOOBSERVEROBJECT     0x0002   // no observer object

#define CONNECTRETRYDEFAULT     3

#define FIXTHREADDEFAULTNUM     3
#define DYNTHREADDEFAULTNUM     5
#define MAXQUEUEDEFAULTNUM      150

#define TIMEOUTDEFAULTSEC       3
#define TIMEOUTDEFAULTUSEC      (100*1000)

#define OBSERVERAPPENDSTRING    "ObserverHandler"
#define INVOKEOBSERVERFUNC      "invokeObserverHandler"
#define REGISTEROBSERVERFUNC    "registerObserverHandler"
#define UNREGISTEROBSERVERFUNC  "unRegisterObserverHandler"

bool RPCCore::m_run_state;
bool RPCCore::m_conf_state;
RPCCore *RPCCore::m_rpc_core;
string RPCCore::m_process_name;
COMMDriver RPCCore::m_comm_base;
ThreadPool *RPCCore::m_threadpool;
struct timeval RPCCore::m_conn_tv;
struct timeval RPCCore::m_comm_tv;
struct SendListHead RPCCore::m_send_head;
RPCConfig *RPCCore::m_conf_file;
ProcessConfig RPCCore::m_process_conf;
UINTHash RPCCore::m_proxy_hash;
StringHash RPCCore::m_service_func_hash;
StringHash RPCCore::m_observer_func_hash;
ObserverHash RPCCore::m_observer_connect_hash;
StringHash RPCCore::m_process_connect_hash;
PointerList RPCCore::m_process_connect_list;
volatile unsigned int RPCCore::m_frame_id;
pthread_cond_t RPCCore::m_send_cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t RPCCore::m_send_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t RPCCore::m_link_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t RPCCore::m_frame_mutex = PTHREAD_MUTEX_INITIALIZER;

RPCCore::RPCCore()
{
    m_frame_id = 0;
    m_rpc_core = NULL;
    m_conf_file = NULL;
    m_run_state = false;
    m_conf_state = false;
    m_process_name.clear();
    m_threadpool = NULL;
    m_core_thread_id = 0;
    LIST_INIT(&m_send_head);
    m_proxy_hash.clear();
    m_service_func_hash.clear();
    m_observer_func_hash.clear();
    m_observer_connect_hash.clear();
    m_process_connect_hash.clear();
    m_process_connect_list.clear();
    memset(&m_conn_tv, 0, sizeof(struct timeval));
    memset(&m_comm_tv, 0, sizeof(struct timeval));
}

RPCCore::~RPCCore()
{
    m_frame_id = 0;
    m_rpc_core = NULL;
    m_conf_file = NULL;
    m_run_state = false;
    m_conf_state = false;
    m_process_name.clear();
    m_threadpool = NULL;
    m_core_thread_id = 0;
    LIST_INIT(&m_send_head);
    m_proxy_hash.clear();
    m_service_func_hash.clear();
    m_observer_func_hash.clear();
    m_observer_connect_hash.clear();
    m_process_connect_hash.clear();
    m_process_connect_list.clear();
    memset(&m_conn_tv, 0, sizeof(struct timeval));
    memset(&m_comm_tv, 0, sizeof(struct timeval));
}

RPCCore *RPCCore::getInstance(void)
{
    if(NULL == m_rpc_core)
        m_rpc_core = new RPCCore();
    return m_rpc_core;
}

int RPCCore::initRPC(const string &process_name, const string &conf_path)
{
    int result = -1;

    result = getExecutableName(m_process_name);
    if(result < 0)
    {
        K_ERROR("RPC : get process name failed!\n");
        return -1;
    }

    m_conf_file = RPCConfig::getInstance();
    if(NULL == m_conf_file)
    {
        K_ERROR("RPC : new RPC configuration memory failed!\n");
        return -1;
    }

    result = m_conf_file->setConfigProfile(conf_path);
    if(0 != result)
        return -1;

    m_conf_state = true;
    return 0;
}

int RPCCore::registerService(const string &service, ServiceHandler func)
{
    if(service.empty())
    {
        K_ERROR("RPC : service name can't be empty!\n");
        return -1;
    }

    if(NULL != m_service_func_hash.find(service))
    {
        K_WARN("RPC : %s server has been exsit!\n", service.c_str());
        return 1;
    }
    return m_service_func_hash.insert(service, (void *) func);
}

int RPCCore::unregisterService(const string &service)
{
    return m_service_func_hash.remove(service);
}

int RPCCore::setResponse(void *msg, void *response_data, size_t response_len)
{
    int result = -1;
    struct timeval tv;
    Message *response = NULL;
    Message *request = (Message *)msg;

    if(NULL == request)
    {
        K_ERROR("RPC : request message can't be NULL!\n");
        return -1;
    }

    if(false == m_run_state)
    {
        K_ERROR("RPC : you must ensure RPC is running before you use!\n");
        return -2;
    }

    if(true == request->checkOnewayStatus())
    {
        K_ERROR("RPC : %s() request is a one way  calling.\n", request->getFunction().c_str());
        K_ERROR("RPC : you can't set response data for this message.\n");
        return -1;
    }

    response = new Message();
    if(NULL == response)
    {
        K_ERROR("RPC : new message memory failed!\n");
        return -1;
    }
    tv = request->getTimeoutTV();
    response->initApplyResponseMessage(&tv, request->getMessageID(), RPCSUCCESS);
    response->setBodyHead(m_process_name, request->getSender(), request->getModule(), request->getFunction());
    result = response->mallocBodyData(response_data, response_len);
    if(0 != result)
    {
        K_ERROR("RPC : response malloc body data failed!\n");
        delete (response);
        return -1;
    }
    response->updateBodySize();
    
    if(m_process_name == response->getRecver()) // module in current process
    {
        result = wakeupOneThread((void *)response);
        if(0 != result)
        {
            K_INFO("RPC : response proxy_hash does't have %u ID message.\n", response->getMessageID());
            releaseRPCMessage((void *)response);
            return result;
        }
    }
    else
    {
        result = insertSenderNode((void *)response);
        if(0 != result)
        {
            K_ERROR("RPC : response insert sender node failed!\n");
            releaseRPCMessage((void *)response);
            return result;
        }
    }
    
    return 0;
}

int RPCCore::proxyCall(const string &module, const string &func, void *send, size_t slen, void *recv, size_t *rlen, struct timeval *tv)
{
    string recver;
    int result = -1;
    unsigned int frame;
    RPCProxy proxy_impl;
    Message *request = NULL;
    Message *response = NULL;
    ProcessConfig process_config;
    struct timeval timetv = {0, 0};
    ServiceHandler func_handler = NULL;

    if(false == m_run_state)
    {
        usleep(200*1000);
        K_ERROR("RPC : you must ensure RPC is running before you use!\n");
        return -2;
    }

    result = m_conf_file->getProcessFromModule(recver, module);
    if(0 != result)
    {
        K_ERROR("RPC : current system does't has %s module, please check!\n", module.c_str());
        return -1;
    }

    result = m_conf_file->getProcessNetConfig(recver, process_config);
    if(0 != result)
    {
        K_ERROR("RPC : %s process does't not have ip-addr config, please check!\n", recver.c_str());
        return -1;
    }

    // if user not set tv, use default timeout to wait
    if((NULL == tv) || ((0 == tv->tv_sec) && (0 == tv->tv_usec)))
    {
        timetv.tv_sec = m_comm_tv.tv_sec;
        timetv.tv_usec = m_comm_tv.tv_usec;
    }
    else
    {
        timetv.tv_sec = tv->tv_sec;
        timetv.tv_usec = tv->tv_usec;
    }

    request = new Message();
    if(NULL == request)
    {
        K_ERROR("RPC : new link message memory failed!\n");
        return -1;
    }
    frame = getFrameID();
    request->initApplyRequestMessage(&timetv, frame, RPCSUCCESS);
    request->setBodyHead(m_process_name, recver, module, func);
    result = request->mallocBodyData(send, slen);
    if(0 != result)
    {
        K_ERROR("RPC : call malloc body data failed!\n");
        releaseRPCMessage((void *)request);
        return -1;
    }
    request->updateBodySize();
    
    if((NULL == recv) || (NULL == rlen) || (0 == *rlen))
    {
        K_WARN("RPC : you will not recv data from %s() calling.\n", func.c_str());
        request->changeOnewayStatus(true);
    }

    result = proxy_impl.init();
    if(0 != result)
    {
        K_ERROR("RPC : init proxy service failed!\n");
        releaseRPCMessage((void *)request);
        return -1;
    }
    m_proxy_hash.insert(frame, (void *)&proxy_impl);
    proxy_impl.lock();
    if(recver == m_process_name) // module in current process
    {
        func_handler = (ServiceHandler)m_service_func_hash.find(func);
        if(NULL == func_handler)
        {
            K_ERROR("RPC : %s module does't has %s function, please check!\n", module.c_str(), func.c_str());
            proxy_impl.unlock();
            m_proxy_hash.remove(frame);
            proxy_impl.destroy();
            releaseRPCMessage((void *)request);
            return -1;
        }
        request->setHandler((void *)func_handler);
        result = m_threadpool->addWork(LowPriority, callBusinessHandler, (void *)request, releaseRPCMessage);
        if(0 != result)
        {
            proxy_impl.unlock();
            m_proxy_hash.remove(frame);
            proxy_impl.destroy();
            releaseRPCMessage((void *)request);
            return -1;
        }
    }
    else
    {
        result = insertSenderNode((void *)request);
        if(0 != result)
        {
            K_ERROR("RPC : call insert sender node failed!\n");
            proxy_impl.unlock();
            m_proxy_hash.remove(frame);
            proxy_impl.destroy();
            releaseRPCMessage((void *)request);
            return result;
        }
    }

    // if this message is oneway, mean no response need to be wait
    // here should not use request, because it will be release on other place
    if((NULL == recv) || (NULL == rlen) || (0 == *rlen))
    {
        proxy_impl.unlock();
        m_proxy_hash.remove(frame);
        proxy_impl.destroy();
        return 0;
    }
    
    result = proxy_impl.wait(timetv);
    response = (Message *)proxy_impl.getResponseMsg();
    proxy_impl.unlock();
    m_proxy_hash.remove(frame);
    proxy_impl.destroy();
    
    if((0 == result) && response)
    {
        size_t recv_len = 0;
        void *recv_data = NULL;
        switch(response->getStatusCode())
        {
            case RPCSUCCESS:
                if((NULL == recv) || (0 == *rlen))
                {
                    K_INFO("RPC : if you want receive data, you should make recv pointer not NULL, and rlen mean recv buffer len!\n");
                    break;
                }

                response->getUserData(&recv_data, &recv_len);
                if((NULL == recv_data) || (0 == recv_len))
                    break;

                if(recv_len > *rlen)
                {
                    recv_len = *rlen;
                    K_WARN("RPC : recv user data buffer not enough!\n");
                }
                memcpy(recv, recv_data, recv_len);
                *rlen = recv_len;
                break;
            case RPCNOSPECIFYSERVICE:
                result = -1;
                K_ERROR("RPC : %s module does't has %s function, please check!\n", module.c_str(), func.c_str());
                break;
            default:
                result = -1;
                K_ERROR("RPC : Unkonw error occur on %s server!\n", response->getSender().c_str());
                break;
        }
    }

    releaseRPCMessage((void *)response);
    return result;
}

int RPCCore::start(void)
{
    int result = -1;
    int fix, dyn, queue;
    struct sockaddr_un u_addr;
    struct sockaddr_in s_addr;
    
    if(false == m_conf_state)
    {
        K_ERROR("RPC : you must set RPC-Configuration before start run!\n");
        return -2;
    }

    // 1.find local socket config
    result = m_conf_file->getProcessConfig(m_process_name, m_process_conf);
    if(0 != result)
    {
        K_ERROR("RPC : could not find %s process addr configuration!\n", m_process_name.c_str());
        return -1;
    }

    // 2.set communicate timeout
    if(0 == m_process_conf.connect_timeout)
    {
        m_conn_tv.tv_sec = TIMEOUTDEFAULTSEC;
        m_conn_tv.tv_usec = TIMEOUTDEFAULTUSEC;
    }
    else
    {
        m_conn_tv.tv_sec = m_process_conf.connect_timeout / 1000;
        m_conn_tv.tv_usec = m_process_conf.connect_timeout % 1000;
    }
    if(0 == m_process_conf.interactive_timeout)
    {
        m_comm_tv.tv_sec = TIMEOUTDEFAULTSEC;
        m_comm_tv.tv_usec = TIMEOUTDEFAULTUSEC;
    }
    else
    {
        m_comm_tv.tv_sec = m_process_conf.interactive_timeout / 1000;
        m_comm_tv.tv_usec = m_process_conf.interactive_timeout % 1000;
    }
    m_comm_base.setTimeout(m_comm_tv);

    // 3.create socket base thread
    if(0 == m_process_conf.listen_port) // use localsocket
    {
        unlink(m_process_conf.ip_address.c_str());
        SocketBaseOpt::initSockaddr(u_addr, m_process_conf.ip_address.c_str());
        result = m_comm_base.create(commEventHandler, (struct sockaddr *)&u_addr, sizeof(u_addr));
    }
    else
    {
        SocketBaseOpt::initSockaddr(s_addr, m_process_conf.ip_address.c_str(), m_process_conf.listen_port);
        result = m_comm_base.create(commEventHandler, (struct sockaddr *)&s_addr, sizeof(s_addr));
    }
    if(0 != result)
        return result;

    // 4.create threadpool
    if(0 == m_process_conf.fix_threads)
        fix = FIXTHREADDEFAULTNUM;
    else
        fix = m_process_conf.fix_threads;
    if(0 == m_process_conf.dyn_threads)
        dyn = DYNTHREADDEFAULTNUM;
    else
        dyn = m_process_conf.dyn_threads;
    if(0 == m_process_conf.max_workqueue)
        queue = MAXQUEUEDEFAULTNUM;
    else
        queue = m_process_conf.max_workqueue;

    m_threadpool = ThreadPool::getInstance();
    if(NULL == m_threadpool)
    {
        K_ERROR("RPC : new threadpool failed!\n");
        m_comm_base.destroy();
        return -1;
    }
    result = m_threadpool->create(fix, dyn, queue);
    if(0 != result)
    {
        K_ERROR("RPC : create threadpool failed!\n");
        m_comm_base.destroy();
        return -1;
    }

    m_run_state = true;
    if(pthread_create(&m_core_thread_id, NULL, RPCCoreThread, NULL) != 0)
    {
        m_run_state = false;
        m_comm_base.destroy();
        K_ERROR("RPC : %s: pthread_create failed, errno:%d,error:%s.\n", __FUNCTION__, errno, strerror(errno));
        return -1;
    }
    
    return 0;
}

int RPCCore::runUntilAskedToQuit(bool state)
{
    void *fdp = NULL;
    struct SendListEntry *sender = NULL;
    
    if(false == m_run_state)
    {
        K_ERROR("RPC : you have't run RPC before!\n");
        return -2;
    }

    if(signal(SIGINT,signalHandler) == SIG_ERR)
        K_ERROR("RPC : register SIGINT failed!\n");
    if(signal(SIGTERM,signalHandler) == SIG_ERR)
        K_ERROR("RPC : register SIGTERM failed!\n");
    if(signal(SIGALRM,signalHandler) == SIG_ERR)
        K_ERROR("RPC : register SIGALRM failed!\n");
    if(signal(SIGSEGV,signalHandler) == SIG_ERR)
        K_ERROR("RPC : register SIGSEGV failed!\n");

    if(false == state)
        K_INFO("You want to stop RPC before business running.\n");
    m_run_state = state;
    while(m_run_state)
    {
        sleep(1);
    }

    // exit send thread
    pthread_cond_signal(&m_send_cond);
    pthread_join(m_core_thread_id, NULL);

    // release all message
    while(NULL != LIST_FIRST(&m_send_head))
    {
        sender = LIST_FIRST(&m_send_head);
        LIST_REMOVE(sender, next);
        releaseRPCMessage((void *)sender->message);
        free(sender);
        sender = NULL;
    }

    // disconnect all socket
    for(int i = 0; i < m_process_connect_list.size();i++)
    {
        if(0 == i)
            fdp = m_process_connect_list.begin();
        else
            fdp = m_process_connect_list.next();
        m_comm_base.disconnect(fdp);
    }
    m_process_connect_list.clear();
    m_threadpool->destroy();
    m_comm_base.destroy();
    
    K_INFO("RPC : RPC framework will exit.\n");
    
    exit(0);
}

int RPCCore::createObserver(const string &observer)
{
    if(observer.empty())
    {
        K_ERROR("RPC : observer name can't be empty!\n");
        return -1;
    }

    if(NULL != m_observer_connect_hash.find(observer))
    {
        K_WARN("RPC : %s observer has been exsit!\n", observer.c_str());
        return 1;
    }
    
    return m_observer_connect_hash.insert(observer);
}

int RPCCore::destroyObserver(const string &observer)
{
    m_observer_connect_hash.remove(observer);
    return 0;
}

int RPCCore::invokeObserver(const string &observer, void *data, size_t len)
{
    int result = -1;
    unsigned int frame;
    Message *request = NULL;
    struct timeval tv = {0, 0};
    string observer_handler(observer);
    ObserverHandler func_handler = NULL;
    string invoke_func(INVOKEOBSERVERFUNC);
    
    if(false == m_run_state)
    {
        K_ERROR("RPC : you must ensure RPC is running before you use!\n");
        return -2;
    }

    if(NULL == m_observer_connect_hash.find(observer))
    {
        K_ERROR("RPC : %s observer has not been exsit!\n", observer.c_str());
        return -1;
    }

    request = new Message();
    if(NULL == request)
    {
        K_ERROR("RPC : new link message memory failed!\n");
        return -1;
    }
    frame = getFrameID();
    request->initObserverInvokeMessage(&tv, frame, RPCSUCCESS);
    request->setBodyHead(m_process_name, observer, observer, invoke_func);
    result = request->mallocBodyData(data, len);
    if(0 != result)
    {
        K_ERROR("RPC : invoke malloc body data failed!\n");
        delete (request);
        return -1;
    }
    request->updateBodySize();

    // local observer call
    observer_handler.append(OBSERVERAPPENDSTRING, strlen(OBSERVERAPPENDSTRING));
    func_handler = (ObserverHandler)m_observer_func_hash.find(observer_handler);
    if(NULL != func_handler)
    {
        request->setHandler((void *)func_handler);
        m_threadpool->addWork(LowPriority, callBusinessHandler, (void *)request, NULL);
    }
    
    // send data to observer
    if(m_observer_connect_hash.empty(observer))
    {
        K_INFO("RPC : observer %s list is empty.\n", observer.c_str());
        releaseRPCMessage((void *)request);
        return 0;
    }

    result = insertSenderNode((void *)request);
    if(0 != result)
    {
        K_ERROR("RPC : invoke insert sender node failed!\n");
        releaseRPCMessage((void *)request);
        return result;
    }
    
    return 0;
}

int RPCCore::registerObserver(const string &module, const string &observer, ObserverHandler func, struct timeval *tv)
{
    string process;
    int result = -1;
    unsigned int frame;
    RPCProxy proxy_impl;
    Message *request = NULL;
    Message *response = NULL;
    ProcessConfig process_config;
    struct timeval timetv = {0, 0};
    string observer_handler(observer);
    string register_func(REGISTEROBSERVERFUNC);
    
    if(observer.empty())
    {
        K_ERROR("RPC : observer name can't be empty!\n");
        return -1;
    }

    if(false == m_run_state)
    {
        K_ERROR("RPC : you must ensure RPC is running before you use!\n");
        return -2;
    }

    result = m_conf_file->getProcessFromModule(process, module);
    if(0 != result)
    {
        K_ERROR("RPC : current system does't has %s module, please check!\n", module.c_str());
        return -1;
    }

    observer_handler.append(OBSERVERAPPENDSTRING, strlen(OBSERVERAPPENDSTRING));
    if(process == m_process_name)  // module in current process
    {
        m_observer_func_hash.insert(observer_handler, (void *)func);
        return 0;
    }
    
    result = m_conf_file->getProcessNetConfig(process, process_config);
    if(0 != result)
    {
        K_ERROR("RPC : %s process does't not have ip-addr config, please check!\n", process.c_str());
        return -1;
    }

    // if user not set tv, use default timeout to wait
    if((NULL == tv) || ((0 == tv->tv_sec) && (0 == tv->tv_usec)))
    {
        timetv.tv_sec = m_comm_tv.tv_sec;
        timetv.tv_usec = m_comm_tv.tv_usec;
    }
    else
    {
        timetv.tv_sec = tv->tv_sec;
        timetv.tv_usec = tv->tv_usec;
    }
    
    request = new Message();
    if(NULL == request)
    {
        K_ERROR("RPC : new link message memory failed!\n");
        return -1;
    }
    frame = getFrameID();
    request->initObserverRequestMessage(&timetv, frame, RPCSUCCESS);
    request->setBodyHead(m_process_name, process, observer, register_func);
    result = request->mallocBodyData(NULL, 0);
    request->updateBodySize();

    result = proxy_impl.init();
    if(0 != result)
    {
        K_ERROR("RPC : init proxy service failed!\n");
        releaseRPCMessage((void *)request);
        return -1;
    }

    m_proxy_hash.insert(frame, (void *)&proxy_impl);
    proxy_impl.lock();
    result = insertSenderNode((void *)request);
    if(0 != result)
    {
        K_ERROR("RPC : register observer insert sender node failed!\n");
        proxy_impl.unlock();
        m_proxy_hash.remove(frame);
        releaseRPCMessage((void *)request);
        return result;
    }
    result = proxy_impl.wait(timetv);
    response = (Message *)proxy_impl.getResponseMsg();
    proxy_impl.unlock();
    m_proxy_hash.remove(frame);
    proxy_impl.destroy();

    if((0 == result) && response)
        m_observer_func_hash.insert(observer_handler, (void *)func);
    
    releaseRPCMessage((void *)response);
    
    return result ? -1 : 0;
}

int RPCCore::unregisterObserver(const string &module, const string &observer, struct timeval *tv)
{
    string process;
    int result = -1;
    unsigned int frame;
    RPCProxy proxy_impl;
    Message *request = NULL;
    Message *response = NULL;
    ProcessConfig process_config;
    struct timeval timetv = {0, 0};
    string observer_handler(observer);
    string unregister_func(UNREGISTEROBSERVERFUNC);

    if(observer.empty())
    {
        K_ERROR("RPC : observer name can't be empty!\n");
        return -1;
    }
    
    if(false == m_run_state)
    {
        K_ERROR("RPC : you must ensure RPC is running before you use!\n");
        return -2;
    }

    result = m_conf_file->getProcessFromModule(process, module);
    if(0 != result)
    {
        K_ERROR("RPC : current system does't has %s module, please check!\n", module.c_str());
        return -1;
    }

    observer_handler.append(OBSERVERAPPENDSTRING, strlen(OBSERVERAPPENDSTRING));
    if(process == m_process_name)  // module in current process
    {
        m_observer_func_hash.remove(observer_handler);
        return 0;
    }
    
    result = m_conf_file->getProcessNetConfig(process, process_config);
    if(0 != result)
    {
        K_ERROR("RPC : %s process does't not have ip-addr config, please check!\n", process.c_str());
        return -1;
    }

    // if user not set tv, use default timeout to wait
    if((NULL == tv) || ((0 == tv->tv_sec) && (0 == tv->tv_usec)))
    {
        timetv.tv_sec = m_comm_tv.tv_sec;
        timetv.tv_usec = m_comm_tv.tv_usec;
    }
    else
    {
        timetv.tv_sec = tv->tv_sec;
        timetv.tv_usec = tv->tv_usec;
    }
    
    request = new Message();
    if(NULL == request)
    {
        K_ERROR("RPC : new link message memory failed!\n");
        return -1;
    }
    frame = getFrameID();
    request->initObserverRequestMessage(&timetv, frame, RPCSUCCESS);
    request->setBodyHead(m_process_name, process, observer, unregister_func);
    result = request->mallocBodyData(NULL, 0);
    request->updateBodySize();

    result = proxy_impl.init();
    if(0 != result)
    {
        K_ERROR("RPC : init proxy service failed!\n");
        releaseRPCMessage((void *)request);
        return -1;
    }

    m_proxy_hash.insert(frame, (void *)&proxy_impl);
    proxy_impl.lock();
    result = insertSenderNode((void *)request);
    if(0 != result)
    {
        K_ERROR("RPC : unregister observer insert sender node failed!\n");
        proxy_impl.unlock();
        m_proxy_hash.remove(frame);
        releaseRPCMessage((void *)request);
        return result;
    }
    result = proxy_impl.wait(timetv);
    response = (Message *)proxy_impl.getResponseMsg();
    proxy_impl.unlock();
    m_proxy_hash.remove(frame);
    proxy_impl.destroy();

    if((0 == result) && response)
        m_observer_func_hash.remove(observer_handler);

    releaseRPCMessage((void *)response);

    return result ? -1 : 0;
}

void RPCCore::signalHandler(int signo)
{
    int size,i;
    char **strings;
    void *array[150];

    switch (signo)
    {
        case SIGINT:
        case SIGTERM:
            /* release system resource, and exit(0) */
            K_WARN("\n\nRPC : receive exit signal.\n");
            m_run_state = false;
            break;

        case SIGALRM:
            break;

        case SIGSEGV:
            K_ERROR("RPC : %s Segment fault:\n", m_process_name.c_str());
            size = backtrace(array,150);
            strings = backtrace_symbols(array,size);
            for(i = 0;i < size;i++)
                K_ERROR(" %d deep : %s\n",i,strings[i]);
            free(strings);
            K_ERROR("RPC : exited!\n");
            exit(-1);
            break;

        default:
            break;
    }
}

void RPCCore::callBusinessHandler(void *msg)
{
    size_t len = 0;
    void *data = NULL;
    ServiceHandler handler = NULL;
    Message *message = (Message *)msg;

    message->getUserData(&data, &len);
    handler = (ServiceHandler)message->getHandler();
    if(handler)
        handler(msg, data, len);
}

int RPCCore::getExecutableName(string &process_name)
{
    char *path_end = NULL;
    char absolute_path[1024];

    memset(absolute_path, '\0', 1024);
    if(readlink("/proc/self/exe", absolute_path, 1024) <= 0)
    {
        K_ERROR("RPC : get executable process name failed!\n");
        return -1;
    }

    path_end = strrchr(absolute_path, '/');
    if(NULL == path_end)
    {
        K_ERROR("RPC : analysis executable process name failed!\n");
        return -1;
    }
    ++path_end;
    process_name.clear();
    process_name = string(path_end);

    return 0;
}

int RPCCore::registerObserverHandler(void *fdp, void *msg)
{
    int result = -1;
    struct timeval tv;
    Message *response = NULL;
    Message *request = (Message *)msg;
    
    response = new Message();
    if(NULL == response)
    {
        K_ERROR("RPC : new message memory failed!\n");
        return -1;
    }

    if(NULL == m_observer_connect_hash.find(request->getModule()))
    {
        K_ERROR("RPC : %s observer is not exsit!\n", request->getModule().c_str());
        return -1;
    }
    m_observer_connect_hash.insert(request->getModule(), fdp);
    
    /* init message head */
    tv = request->getTimeoutTV();
    response->initObserverResponseMessage(&tv, request->getMessageID(), RPCSUCCESS);
    /* init body head */
    response->setBodyHead(m_process_name, request->getSender(), request->getModule(), request->getFunction());
    /* init body data */
    response->mallocBodyData(NULL, 0);
    response->updateBodySize();
    
    result = insertSenderNode((void *)response);
    if(0 != result)
    {
        K_ERROR("RPC : register observer handler insert sender node failed!\n");
        releaseRPCMessage((void *)response);
        return result;
    }

    return 0;
}

int RPCCore::unregisterObserverHandler(void *fdp, void *msg)
{
    int result = -1;
    struct timeval tv;
    Message *response = NULL;
    Message *request = (Message *)msg;
    
    response = new Message();
    if(NULL == response)
    {
        K_ERROR("RPC : new message memory failed!\n");
        return -1;
    }

    if(NULL == m_observer_connect_hash.find(request->getModule()))
    {
        K_ERROR("RPC : %s observer is not exsit!\n", request->getModule().c_str());
        return -1;
    }
    m_observer_connect_hash.remove(request->getModule(), fdp);
    
    /* init message head */
    tv = request->getTimeoutTV();
    response->initObserverResponseMessage(&tv, request->getMessageID(), RPCSUCCESS);
    /* init body head */
    response->setBodyHead(m_process_name, request->getSender(), request->getModule(), request->getFunction());
    /* init body data */
    response->mallocBodyData(NULL, 0);
    response->updateBodySize();
    
    result = insertSenderNode((void *)response);
    if(0 != result)
    {
        K_ERROR("RPC : unregister observer handler insert sender node failed!\n");
        releaseRPCMessage((void *)response);
        return result;
    }
    
    return 0;
}

int RPCCore::commEventHandler(unsigned int type, void *fdp, void *data, size_t len)
{
    switch(type)
    {
        case COMMEventRecv:
            if(len)
                analyseReceiveData(fdp, data, len);
            break;
            
        case COMMEventSend:
            break;
            
        case COMMEventConnect:
            if(len == 1)  // connect ok
                m_process_connect_list.insert(fdp);
            break;

        case COMMEventDisconnect:
            if(len == 1) // disconnect ok
                m_process_connect_list.remove(fdp);
            m_process_connect_hash.remove(fdp);
            m_observer_connect_hash.remove(fdp);
            break;

        case COMMEventCheck:
            break;
            
        case COMMEventRTimeout:
            break;
            
        case COMMEventSTimeout:
            break;
            
        default:
            break;
    }

    return 0;
}

int RPCCore::requestLink(void *fdp, void *msg)
{
    size_t len = 0;
    int result = -1;
    void * data = NULL;
    unsigned int frame;
    RPCProxy proxy_impl;
    size_t link_len = 0;
    void * tmp_fd = NULL;
    void *link_data = NULL;
    Message *request = NULL;
    Message *response = NULL;
    Message *message = (Message *)msg;
    unsigned char deal_connect; // 0, disconnect; 1, connect
    
    result = proxy_impl.init();
    if(0 != result)
    {
        K_ERROR("RPC : init proxy service failed!\n");
        return -1;
    }
    
    request = new Message();
    if(NULL == request)
    {
        K_ERROR("RPC : new link message memory failed!\n");
        proxy_impl.destroy();
        return -1;
    }

    frame = getFrameID();
    request->initLinkRequestMessage(&m_comm_tv, frame, RPCSUCCESS);
    request->setSender(m_process_name);
    request->setRecver(message->getRecver());
    request->mallocBodyData(NULL, 0);
    request->updateBodySize();
    
REPEAT_SEND:
    result = request->serializeMessage(&link_data, &link_len);
    if(0 != result)
        goto REPEAT_SEND;
    
    pthread_mutex_lock(&m_link_mutex);
    tmp_fd = m_process_connect_hash.find(message->getRecver());
    if(tmp_fd != NULL)
    {
        pthread_mutex_unlock(&m_link_mutex);
        request->releaseSerializeMessage(link_data);
        releaseRPCMessage((void *)request);
        proxy_impl.destroy();
        return 1;
    }
    m_process_connect_hash.insert(message->getRecver(), fdp);
    pthread_mutex_unlock(&m_link_mutex);
    
    m_proxy_hash.insert(frame, (void *)&proxy_impl);
    proxy_impl.lock();
    m_comm_base.send(fdp, link_data, link_len);
    result = proxy_impl.wait(m_comm_tv);
    response = (Message *)proxy_impl.getResponseMsg();
    proxy_impl.unlock();
    m_proxy_hash.remove(frame);
    request->releaseSerializeMessage(link_data);
    proxy_impl.destroy();
    releaseRPCMessage((void *)request);
    
    pthread_mutex_lock(&m_link_mutex);
    tmp_fd = m_process_connect_hash.find(message->getRecver());
    if(tmp_fd != fdp) // confilt, new connect
    {
        pthread_mutex_unlock(&m_link_mutex);
        releaseRPCMessage((void *)response);
        return 1;
    }
    
    if((0 == result) && response)
    {
        response->getUserData(&data, &len);
        deal_connect = *(unsigned char *)data;
        if(0 == deal_connect)
        {
            result = 1;
            m_process_connect_hash.remove(message->getRecver());
            m_process_connect_hash.insert(message->getRecver(), response->getHandler());
        }
    }
    else
    {
        m_process_connect_hash.remove(message->getRecver());
    }
    pthread_mutex_unlock(&m_link_mutex);
    
    releaseRPCMessage((void *)response);
    
    return result;
}

int RPCCore::responseLink(void *fdp, void *msg)
{
    int result = -1;
    struct timeval tv;
    size_t link_len = 0;
    void *exsit_fd = NULL;
    void *link_data = NULL;
    Message *response = NULL;
    unsigned char deal_connect = 1; // 0, disconnect; 1, connect
    Message *request = (Message *)msg;
    
    response = new Message();
    if(NULL == response)
    {
        K_ERROR("RPC : new message memory failed!\n");
        return -1;
    }

    tv = request->getTimeoutTV();
    response->initLinkResponseMessage(&tv, request->getMessageID(), RPCSUCCESS);
    response->setSender(m_process_name);
    response->setRecver(request->getSender());
    result = response->mallocBodyData(&deal_connect, 1);
    if(0 != result)
    {
        K_ERROR("RPC : link response analyse malloc body data failed!\n");
        delete (response);
        return -1;
    }
    response->updateBodySize();

REPEAT_SEND:
    result = response->serializeMessage(&link_data, &link_len);
    if(0 != result)
        goto REPEAT_SEND;

    pthread_mutex_lock(&m_link_mutex);
    exsit_fd = m_process_connect_hash.find(request->getSender());
    if(exsit_fd)
    {
        if(m_process_name < request->getSender())
        {
            deal_connect = 0;  // disconnect client
        }
        else
        {
            deal_connect = 1;  // disconnect self
            m_process_connect_hash.remove(request->getSender());
            m_process_connect_hash.insert(request->getSender(), fdp);
        }
    }
    else
    {
        m_process_connect_hash.insert(request->getSender(), fdp);
    }
    pthread_mutex_unlock(&m_link_mutex);
    
    if(deal_connect)
        result = m_comm_base.send(fdp, link_data, link_len);
    else
        result = m_comm_base.send(exsit_fd, link_data, link_len);
    
    response->releaseSerializeMessage(link_data);
    releaseRPCMessage((void *)response);
    
    return 0;
}

int RPCCore::insertSenderNode(void *message)
{
    struct SendListEntry *sender = NULL;
    
    sender = (struct SendListEntry *)malloc(sizeof(struct SendListEntry));
    if(NULL == sender)
        return -1;
    
    pthread_mutex_lock(&m_send_mutex);
    sender->message = message;
    LIST_INSERT_HEAD(&m_send_head, sender, next);
    pthread_cond_signal(&m_send_cond);
    pthread_mutex_unlock(&m_send_mutex);

    return 0;
}

int RPCCore::connectToProcess(string process, void **connect_fd)
{
    int result = -1;
    struct sockaddr_un u_addr;
    struct sockaddr_in s_addr;
    ProcessConfig process_config;
    
    m_conf_file->getProcessNetConfig(process, process_config);
    if(0 == process_config.listen_port)
    {
        SocketBaseOpt::initSockaddr(u_addr, process_config.ip_address.c_str());
        result = m_comm_base.connect((struct sockaddr *)&u_addr, sizeof(u_addr), m_conn_tv, connect_fd);
    }
    else
    {
        SocketBaseOpt::initSockaddr(s_addr, process_config.ip_address.c_str(), process_config.listen_port);
        result = m_comm_base.connect((struct sockaddr *)&s_addr, sizeof(s_addr), m_conn_tv, connect_fd);
    }
    
    return result;
}

void *RPCCore::RPCCoreThread(void *arg)
{
    int result = -1;
    size_t send_len = 0;
    void *send_data = NULL;
    void *connect_fd = NULL;
    Message *message = NULL;
    void *connect_tmp_fd = NULL;
    volatile int connect_count = 0;
    struct SendListEntry *sender = NULL;

    K_INFO("RPC : send thread running, id:%lu\n",pthread_self());

    while(m_run_state)
    {
        pthread_mutex_lock(&m_send_mutex);
        while((LIST_FIRST(&m_send_head) == NULL) && m_run_state)
        {
            pthread_cond_wait(&m_send_cond, &m_send_mutex);
        }

        if(!m_run_state)
        {
            pthread_mutex_unlock(&m_send_mutex);
            break;
        }
        assert(LIST_FIRST(&m_send_head) != NULL);
        sender = LIST_FIRST(&m_send_head);
        LIST_REMOVE(sender, next);
        assert(sender->message != NULL);
        pthread_mutex_unlock(&m_send_mutex);

        message = (Message *)sender->message;
        if((MT_OBSER_PK == message->getMessageType()) && (string(INVOKEOBSERVERFUNC) == message->getFunction()))
        {
            OBSERVER_IT fd_it;
            OBSERVER_LIST_PTR list_ptr;
            list_ptr = m_observer_connect_hash.find(message->getRecver());
            if((NULL == list_ptr) || list_ptr->empty())
                goto FREE_MEMORY;
        REPEAT_SERIALIZE:
            result = message->serializeMessage(&send_data, &send_len);
            if(0 != result)
                goto REPEAT_SERIALIZE;
            for(fd_it = list_ptr->begin(); fd_it != list_ptr->end(); fd_it++)
            {
                // send message to all observer
                m_comm_base.send(*fd_it, send_data, send_len);
            }
            message->releaseSerializeMessage(send_data);
            send_data = NULL;
            goto FREE_MEMORY;
        }
        
    REPEAT_CONNECT:
        pthread_mutex_lock(&m_link_mutex);
        connect_fd = m_process_connect_hash.find(message->getRecver());
        pthread_mutex_unlock(&m_link_mutex);
        if(NULL == connect_fd)  // connect not exsit
        {
            if(CONNECTRETRYDEFAULT == connect_count)
                goto FREE_MEMORY;
            result = connectToProcess(message->getRecver(), &connect_tmp_fd);
            if(0 != result)
            {
                connect_count++;
                goto REPEAT_CONNECT;
            }

            // when connect OK, we send a link package
            result = requestLink(connect_tmp_fd, (void *)message);
            if((1 == result) || (result < 0))
            {
                m_comm_base.disconnect(connect_tmp_fd);
                goto REPEAT_CONNECT;
            }
            
            connect_fd = connect_tmp_fd;
        }
        
REPEAT_SEND: // start to send data
        result = message->serializeMessage(&send_data, &send_len);
        if(0 != result)
            goto REPEAT_SEND;
        result = m_comm_base.send(connect_fd, send_data, send_len);
        message->releaseSerializeMessage(send_data);
        send_data = NULL;

FREE_MEMORY:
        connect_count = 0;
        releaseRPCMessage((void *)message);
        free(sender);
        sender = NULL;
    }
    
    K_INFO("RPC : send thread exit.\n");
    
    pthread_exit(NULL);
}

int RPCCore::wakeupOneThread(void *msg)
{
    Message *message = (Message *)msg;
    
    RPCProxy *proxy_impl = (RPCProxy *)m_proxy_hash.find(message->getMessageID());
    if(NULL == proxy_impl)
        return -1;
    
    proxy_impl->lock();
    proxy_impl->setResponseMsg(message);
    proxy_impl->wakeup();
    proxy_impl->unlock();
    
    return 0;
}

int RPCCore::responseErrorCodeACK(void *fdp, void *msg)
{
    int result = -1;
    struct timeval tv;
    Message *response = NULL;
    Message *request = (Message *)msg;
    
    response = new Message();
    if(NULL == response)
    {
        K_ERROR("RPC : new message memory failed!\n");
        return -1;
    }

    tv = request->getTimeoutTV();
    response->initApplyResponseMessage(&tv, request->getMessageID(), RPCNOSPECIFYSERVICE);
    response->setBodyHead(m_process_name, request->getSender(), request->getModule(), request->getFunction());
    response->mallocBodyData(NULL, 0);
    response->updateBodySize();

    result = insertSenderNode((void *)response);
    if(0 != result)
    {
        K_ERROR("RPC : error code insert sender node failed!\n");
        releaseRPCMessage((void *)response);
        return result;
    }

    return 0;
}

unsigned int RPCCore::getFrameID(void)
{
    unsigned int temp_id;
    pthread_mutex_lock(&m_frame_mutex);
    temp_id = m_frame_id++;
    pthread_mutex_unlock(&m_frame_mutex);
    return temp_id;
}

void RPCCore::releaseRPCMessage(void *arg)
{
    Message *message = (Message *)arg;
    if(message)
    {
        message->releaseBodyData();
        delete (message);
    }
}

int RPCCore::analyseReceiveData(void *fdp, const void *data, size_t len)
{
    int result = -1;
    Message *message = NULL;
    ServiceHandler func_handler = NULL;
    unsigned char *ptr = (unsigned char *)data;
    
REPEAT_ANALYSE:
    message = new Message();
    if(NULL == message)
    {
        K_ERROR("RPC : new message memory failed on receive!\n");
        goto REPEAT_ANALYSE;
    }
    message->getMessageHeadFromData((void *)ptr);
    ptr += MESSAGE_HEAD_SIZE;
    message->getBodyHead((void *)ptr);
    ptr += message->getBodyHeadSize();
    result = message->mallocBodyData((void *)ptr, len - MESSAGE_HEAD_SIZE - message->getBodyHeadSize());
    if(0 != result)
    {
        K_ERROR("RPC : analyse malloc body data failed!\n");
        delete (message);
        return -1;
    }
    
    switch(message->getMessageType())
    {
        case MT_LINK_PK:
            if(message->checkResponseStatus())
            {
                message->setHandler(fdp);
                result = wakeupOneThread((void *)message);
                if(0 != result)
                {
                    K_INFO("RPC : link proxy_hash does't have %u ID message.\n", message->getMessageID());
                    releaseRPCMessage((void *)message);
                    return result;
                }
            }
            else  // applay message
            {
                return responseLink(fdp, (void *)message);
            }
            break;

        case MT_BEAT_PK:
            releaseRPCMessage((void *)message);
            break;

        case MT_APPLY_PK:
            if(message->checkResponseStatus())
            {
                result = wakeupOneThread((void *)message);
                if(0 != result)
                {
                    K_INFO("RPC : request proxy_hash does't have %u ID message.\n", message->getMessageID());
                    releaseRPCMessage((void *)message);
                    return result;
                }
            }
            else
            {
                func_handler = (ServiceHandler)m_service_func_hash.find(message->getFunction());
                if(NULL == func_handler)
                {
                    K_ERROR("RPC : %s module does't has %s function, please check!\n", message->getModule().c_str(), message->getFunction().c_str());
                    responseErrorCodeACK(fdp, (void *)message);
                    releaseRPCMessage((void *)message);
                    return -1;
                }
                message->setHandler((void *)func_handler);
                result = m_threadpool->addWork(LowPriority, callBusinessHandler, (void *)message, releaseRPCMessage);
                if(0 != result)
                {
                    releaseRPCMessage((void *)message);
                    return -1;
                }
            }
            break;

        case MT_OBSER_PK:
            if(message->checkResponseStatus())
            {
                result = wakeupOneThread((void *)message);
                if(0 != result)
                {
                    K_WARN("RPC : observer proxy_hash does't have %u ID message.\n", message->getMessageID());
                    releaseRPCMessage((void *)message);
                    return result;
                }
            }
            else
            {
                if(string(INVOKEOBSERVERFUNC) == message->getFunction())
                {
                    string observer_handler(message->getModule());
                    observer_handler.append(OBSERVERAPPENDSTRING, strlen(OBSERVERAPPENDSTRING));
                    func_handler = (ObserverHandler)m_observer_func_hash.find(observer_handler);
                    if(NULL == func_handler)
                    {
                        K_ERROR("RPC : does't has %s observer function, please check!\n", message->getModule().c_str());
                        responseErrorCodeACK(fdp, (void *)message);
                        releaseRPCMessage((void *)message);
                        return -1;
                    }
                    message->setHandler((void *)func_handler);
                    result = m_threadpool->addWork(LowPriority, callBusinessHandler, (void *)message, releaseRPCMessage);
                    if(0 != result)
                    {
                        releaseRPCMessage((void *)message);
                        return -1;
                    }
                    return 0;
                }
                else if(string(REGISTEROBSERVERFUNC) == message->getFunction())
                {
                    registerObserverHandler(fdp, (void *)message);
                    releaseRPCMessage((void *)message);
                }
                else if(string(UNREGISTEROBSERVERFUNC) == message->getFunction())
                {
                    unregisterObserverHandler(fdp, (void *)message);
                    releaseRPCMessage((void *)message);
                }
            }
            break;

        default:
            releaseRPCMessage((void *)message);
            break;
    }
    
    return 0;
}

