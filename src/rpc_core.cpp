/* rpc_core.cpp
 * DO NOT EDIT THIS FILE.
 * Date  : 2017-11-22
 * Author: Konishi
 * Email : konishi5202@163.com
 */
#include <time.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <assert.h>
#include <unistd.h>
#include <pthread.h>
#include <execinfo.h>

#include <sys/un.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

#include "msg.h"
#include "rpc_core.h"
#include "rpc_proxy.h"
#include "socket_base.h"

#define K_DEBUG   printf
#define K_INFO    printf
#define K_WARN    printf
#define K_ERROR   printf

/* Error Code List */
#define RPCSUCCESS              0x0000
#define RPCNOSPECIFYSERVICE     0x0001   // no service

#define CONNECTRETRYDEFAULT     3

#define FIXTHREADDEFAULTNUM     5
#define DYNTHREADDEFAULTNUM     8
#define MAXQUEUEDEFAULTNUM      150

#define TIMEOUTDEFAULTSEC       0
#define TIMEOUTDEFAULTUSEC      30*1000

RPCCore *RPCCore::m_rpc;
string RPCCore::m_process;
bool RPCCore::m_run_state;
bool RPCCore::m_conf_state;
UINTHash RPCCore::m_proxy_hash;
StringHash RPCCore::m_func_hash;
COMMDriver RPCCore::m_comm_base;
ThreadPool *RPCCore::m_threadpool;
struct timeval RPCCore::m_conn_tv;
struct timeval RPCCore::m_comm_tv;
StringHash RPCCore::m_connect_hash;
PointerList RPCCore::m_connect_list;
ModuleConfig RPCCore::module_config;
NetworkConfig RPCCore::network_config;
struct WorkerHead RPCCore::m_work_head;
volatile unsigned int RPCCore::m_frame_id;
pthread_cond_t RPCCore::m_send_cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t RPCCore::m_send_mutex = PTHREAD_MUTEX_INITIALIZER;

RPCCore::RPCCore()
{
    m_rpc = NULL;
    m_process.clear();
    m_run_state = false;
    m_conf_state = false;
    m_proxy_hash.clear();
    m_func_hash.clear();
    LIST_INIT(&m_work_head);
    m_frame_id = 0;
    m_threadpool = NULL;
    m_send_thread_id = 0;
    m_connect_hash.clear();
    m_connect_list.clear();
    memset(&m_conn_tv, 0, sizeof(struct timeval));
    memset(&m_comm_tv, 0, sizeof(struct timeval));
}

RPCCore::~RPCCore()
{
    m_rpc = NULL;
    m_process.clear();
    m_run_state = false;
    m_conf_state = false;
    m_proxy_hash.clear();
    m_func_hash.clear();
    LIST_INIT(&m_work_head);
    m_frame_id = 0;
    m_threadpool = NULL;
    m_send_thread_id = 0;
    m_connect_hash.clear();
    m_connect_list.clear();
    memset(&m_conn_tv, 0, sizeof(struct timeval));
    memset(&m_comm_tv, 0, sizeof(struct timeval));
}

RPCCore *RPCCore::getInstance(void)
{
    if(NULL == m_rpc)
        m_rpc = new RPCCore();
    return m_rpc;
}

int RPCCore::setProcessName(const char *process)
{
    if(process[0] == '.')
        this->m_process = &process[2];
    else
        this->m_process = process;
    
    return 0;
}

int RPCCore::setConfigProfile(const string &network, const string &module)
{
    int result = -1;

    if(0 == this->m_process.size())
    {
        K_ERROR("RPC : please set process name first!\n");
        return -1;
    }
    
    result = network_config.setConfigProfile(network);
    if(result == 0)
        result = module_config.setConfigProfile(module);
    if(result == 0)
        m_conf_state = true;
    
    return 0;
}

int RPCCore::addService(const char *service, ServerFunction func)
{
    string key(service);
    
    if(NULL == service)
    {
        K_ERROR("RPC : service name can't be NULL!\n");
        return -1;
    }

    if(false == m_conf_state)
    {
        K_ERROR("RPC : you must set RPC-Configuration before you use!\n");
        return -1;
    }

    if(NULL != m_func_hash.find(key))
    {
        K_ERROR("RPC : %s server has been exsit!\n", service);
        return -1;
    }
    return m_func_hash.insert(key, (void *) func);
}

int RPCCore::setResponse(void *msg, void *response_data, size_t response_len)
{
    int result = -1;
    struct timespec tp;
    Message *response = NULL;
    Message *request = (Message *)msg;

    if(NULL == request)
    {
        K_ERROR("RPC : request message can't be NULL!\n");
        return -1;
    }

    if(false == m_run_state)
    {
        K_ERROR("RPC : you must ensure RPC is running before you use!\n");
        return -1;
    }

    response = new Message();
    if(NULL == response)
    {
        K_ERROR("RPC : new message memory failed!\n");
        return -1;
    }

    /* init message head */
    tp = request->getTimeoutTP();
    response->initApplyResponseMessage(&tp, request->getMessageID(), RPCSUCCESS);
    /* init body head */
    response->setBodyHead(m_process, request->getSender(), request->getModule(), request->getFunction());
    /* init body data */
    result = response->mallocBodyData(response_data, response_len);
    if(0 != result)
    {
        delete (response);
        return -1;
    }
    response->updateBodySize();
    if(m_process == response->getRecver()) // module in current process
    {
        RPCProxy *proxy_impl = (RPCProxy *)m_proxy_hash.find(response->getMessageID());
        if(NULL == proxy_impl)
        {
            response->releaseBodyData();
            delete (response);
            return -1;
        }
        proxy_impl->setResponseMsg((void *)response);
        proxy_impl->wakeup();
    }
    else
    {
        struct WorkerEntry *worker = (struct WorkerEntry *)malloc(sizeof(struct WorkerEntry));
        if(NULL == worker)
        {
            K_ERROR("RPC : malloc WorkerEntry struct failed!\n");
            response->releaseBodyData();
            delete (response);
            return -1;
        }
        worker->message = (void *)response;
        addSendWorker((void *)worker);
    }
    
    return 0;
}

int RPCCore::proxyCall(const string &module, const string &func, void *send, size_t slen, void *recv, size_t &rlen)
{
    string recver;
    int result = -1;
    unsigned int frame;
    RPCProxy proxy_impl;
    SocketStruct dest_addr;
    Message *request = NULL;
    Message *response = NULL;
    struct timespec tp = {0, 0};
    ServerFunction func_handler = NULL;

    if(false == m_run_state)
    {
        K_ERROR("RPC : you must ensure RPC is running before you use!\n");
        return -1;
    }

    result = module_config.referModule(module, recver);
    if(0 != result)
    {
        K_ERROR("RPC : current system does't has %s module, please check!\n", module.c_str());
        return -1;
    }

    result = network_config.getNetworkConfig(recver, dest_addr);
    if(0 != result)
    {
        K_ERROR("RPC : %s process does't not have ip-addr config, please check!\n", recver.c_str());
        return -1;
    }

    request = new Message();
    if(NULL == request)
    {
        K_ERROR("RPC : new link message memory failed!\n");
        return -1;
    }
    frame = getFrameID();
    request->initApplyRequestMessage(&tp, frame, RPCSUCCESS);
    request->setBodyHead(m_process, recver, module, func);
    result = request->mallocBodyData(send, slen);
    if(0 != result)
    {
        delete (request);
        return -1;
    }
    request->updateBodySize();
    if(recver == m_process) // module in current process
    {
        func_handler = (ServerFunction)m_func_hash.find(func);
        if(NULL == func_handler)
        {
            K_ERROR("RPC : %s module does't has %s function, please check!\n", module.c_str(), func.c_str());
            request->releaseBodyData();
            delete (request);
            return -1;
        }

        result = m_threadpool->addWork(LowPriority, func_handler, (void *)request, releaseRPCMessage);
        if(0 != result)
        {
            request->releaseBodyData();
            delete (request);
            return -1;
        }
    }
    else
    {
        struct WorkerEntry *worker = (struct WorkerEntry *)malloc(sizeof(struct WorkerEntry));
        if(NULL == worker)
        {
            K_ERROR("RPC : malloc WorkerEntry struct failed!\n");
            request->releaseBodyData();
            delete (request);
            return -1;
        }
        worker->message = (void *)request;
        this->addSendWorker((void *)worker);
    }

    result = proxy_impl.init();
    if(0 != result)
    {
        K_ERROR("RPC : init proxy service failed!\n");
        return -1;
    }
    m_proxy_hash.insert(frame, (void *)&proxy_impl);
    result = proxy_impl.wait(m_comm_tv);
    m_proxy_hash.remove(frame);
    response = (Message *)proxy_impl.getResponseMsg();
    proxy_impl.destroy();

    if((0 == result) && response)
    {
        size_t recv_len = 0;
        void *recv_data = NULL;
        switch(response->getStatusCode())
        {
            case RPCSUCCESS:
                if((NULL == recv) || (0 == rlen))
                {
                    K_INFO("RPC : if you want receive data, you should make recv pointer not NULL, and rlen mean recv buffer len!\n");
                    break;
                }

                response->getUserData(&recv_data, &recv_len);
                if((NULL == recv_data) || (0 == recv_len))
                    break;

                if(recv_len > rlen)
                {
                    recv_len = rlen;
                    K_WARN("RPC : recv user data buffer not enough!\n");
                }
                memcpy(recv, recv_data, recv_len);
                rlen = recv_len;
                break;
            case RPCNOSPECIFYSERVICE:
                K_ERROR("RPC : %s module does't has %s function, please check!\n", module.c_str(), func.c_str());
                break;
            default:
                K_ERROR("RPC : Unkonw error occur on %s server!\n", response->getSender().c_str());
                break;
        }
    }

    if(response)
    {
        response->releaseBodyData();
        delete (response);
    }
    
    return 0;
}

int RPCCore::start(void)
{
    int result = -1;
    int fix, dyn, queue;
    SocketStruct socket_str;
    struct sockaddr_un u_addr;
    struct sockaddr_in s_addr;

    if(false == m_conf_state)
    {
        K_ERROR("RPC : you must set RPC-Configuration before start run!\n");
        return -1;
    }

    // 1.find local socket config
    result = network_config.getNetworkConfig(m_process, socket_str);
    if(0 != result)
    {
        K_ERROR("RPC : could not find %s process addr configuration!\n", m_process.c_str());
        return -1;
    }

    // 2.set communicate timeout
    network_config.getConnectTimeout(&m_conn_tv);
    if((m_conn_tv.tv_sec == 0) && (m_conn_tv.tv_usec == 0))
    {
        m_conn_tv.tv_sec = TIMEOUTDEFAULTSEC;
        m_conn_tv.tv_usec = TIMEOUTDEFAULTUSEC;
    }
    network_config.getCommunicateTimeout(&m_comm_tv);
    if((m_comm_tv.tv_sec == 0) && (m_comm_tv.tv_usec == 0))
    {
        m_comm_tv.tv_sec = TIMEOUTDEFAULTSEC;
        m_comm_tv.tv_usec = TIMEOUTDEFAULTUSEC;
    }
    m_comm_base.setTimeout(m_comm_tv);

    // 3.create socket base thread
    if(socket_str.port == 0) // use localsocket
    {
        unlink(socket_str.ipaddr.c_str());
        SocketBaseOpt::initSockaddr(u_addr, socket_str.ipaddr.c_str());
        result = m_comm_base.create(eventHandler, (struct sockaddr *)&u_addr, sizeof(u_addr));
    }
    else
    {
        SocketBaseOpt::initSockaddr(s_addr, socket_str.ipaddr.c_str(), socket_str.port);
        result = m_comm_base.create(eventHandler, (struct sockaddr *)&s_addr, sizeof(s_addr));
    }
    if(0 != result)
        return result;

    // 4.create threadpool
    fix = module_config.getFixThreadNum();
    if(fix <= 0)
        fix = FIXTHREADDEFAULTNUM;
    dyn = module_config.getDynThreadNum();
    if(dyn <= 0)
        dyn = DYNTHREADDEFAULTNUM;
    queue = module_config.getMaxQueueNum();
    if(queue <= 0)
        queue = MAXQUEUEDEFAULTNUM;

    m_threadpool = ThreadPool::getInstance();
    if(NULL == m_threadpool)
    {
        K_ERROR("RPC : new threadpool failed!\n");
        m_comm_base.destroy();
        return -1;
    }
    result = m_threadpool->create(fix, dyn, queue);
    if(0 != result)
    {
        K_ERROR("RPC : create threadpool failed!\n");
        m_comm_base.destroy();
        return -1;
    }

    m_run_state = true;
    if(pthread_create(&m_send_thread_id, NULL, sendThread, NULL) != 0)
    {
        m_run_state = false;
        K_ERROR("RPC : %s: pthread_create failed, errno:%d,error:%s.\n", __FUNCTION__, errno, strerror(errno));
        return -1;
    }
    
    return 0;
}

int RPCCore::runUntilAskedToQuit(bool state)
{
    void *fdp = NULL;
    struct WorkerEntry *worker = NULL;
    
    if(false == m_run_state)
    {
        K_ERROR("RPC : you have't RPC before!");
        exit(-1);
    }

    if(signal(SIGINT,signalHandler) == SIG_ERR)
        K_ERROR("RPC : register SIGINT failed!");
    if(signal(SIGTERM,signalHandler) == SIG_ERR)
        K_ERROR("RPC : register SIGTERM failed!");
    if(signal(SIGALRM,signalHandler) == SIG_ERR)
        K_ERROR("RPC : register SIGALRM failed!");
    if(signal(SIGSEGV,signalHandler) == SIG_ERR)
        K_ERROR("RPC : register SIGSEGV failed!");

    if(false == state)
        K_INFO("You want to stop RPC before business running.\n");
    m_run_state = state;
    while(m_run_state)
    {
        sleep(1);
    }

    // exit send thread
    pthread_cond_signal(&m_send_cond);
    pthread_join(m_send_thread_id, NULL);
    
    // release all message
    while(NULL != LIST_FIRST(&m_work_head))
    {
        worker = LIST_FIRST(&m_work_head);
        LIST_REMOVE(worker, worker_next);
        releaseRPCMessage((void *)worker->message);
        free(worker);
        worker = NULL;
    }
    
    // disconnect all socket
    fdp = m_connect_list.begin();
    if(fdp)
    {
        for(; m_connect_list.hasNext(); fdp = m_connect_list.next())
            m_comm_base.disconnect(fdp);
    }
    m_connect_list.clear();
    m_threadpool->destroy();
    m_comm_base.destroy();
    
    exit(0);
}

void RPCCore::getUserData(void *msg, void **data_ptr, size_t *data_len)
{
    Message *message = (Message *)msg;
    message->getUserData(data_ptr , data_len);
}

void RPCCore::addSendWorker(void *worker)
{
    pthread_mutex_lock(&m_send_mutex);
    LIST_INSERT_HEAD(&m_work_head, (struct WorkerEntry *)worker, worker_next);
    pthread_cond_signal(&m_send_cond);
    pthread_mutex_unlock(&m_send_mutex);
}

void *RPCCore::sendThread(void *arg)
{
    int result = -1;
    size_t send_len = 0;
    SocketStruct dest_addr;
    void *send_data = NULL;
    void *connect_fd = NULL;
    Message *message = NULL;
    struct sockaddr_un u_addr;
    struct sockaddr_in s_addr;
    void *connect_tmp_fd = NULL;
    volatile int connect_count = 0;
    struct WorkerEntry *worker = NULL;

    K_INFO("RPC : send thread running, id:%lu\n",pthread_self());

    while(m_run_state)
    {
        pthread_mutex_lock(&m_send_mutex);
        while((LIST_FIRST(&m_work_head) == NULL) && m_run_state)
        {
            pthread_cond_wait(&m_send_cond, &m_send_mutex);
        }

        if(!m_run_state)
        {
            pthread_mutex_unlock(&m_send_mutex);
            break;
        }
        assert(LIST_FIRST(&m_work_head) != NULL);
        worker = LIST_FIRST(&m_work_head);
        LIST_REMOVE(worker, worker_next);
        assert(worker->message != NULL);
        pthread_mutex_unlock(&m_send_mutex);

        message = (Message *)worker->message;
        connect_fd = m_connect_hash.find(message->getRecver());
        if(NULL == connect_fd)  // connect not exsit
        {
        REPEAT_CONNECT:
            if(CONNECTRETRYDEFAULT == connect_count)
                goto FREE_MEMORY;
            network_config.getNetworkConfig(message->getRecver(), dest_addr);
            if(0 == dest_addr.port)
            {
                SocketBaseOpt::initSockaddr(u_addr, dest_addr.ipaddr.c_str());
                result = m_comm_base.connect((struct sockaddr *)&u_addr, sizeof(u_addr), m_conn_tv, &connect_tmp_fd);
            }
            else
            {
                SocketBaseOpt::initSockaddr(s_addr, dest_addr.ipaddr.c_str(), dest_addr.port);
                result = m_comm_base.connect((struct sockaddr *)&s_addr, sizeof(s_addr), m_conn_tv, &connect_tmp_fd);
            }
            if(0 != result)
            {
                // meybe need wait a while
                // usleep(50*1000);
                connect_count++;
                goto REPEAT_CONNECT;
            }

            // when connect OK, we send a link package
            result = sendLinkMessage(connect_tmp_fd);
            if(0 != result)
            {
                if(NULL != m_connect_list.find(connect_tmp_fd))
                {
                    m_connect_list.remove(connect_tmp_fd);
                    m_comm_base.disconnect(connect_tmp_fd);
                }
                goto REPEAT_CONNECT;
            }

            // link message OK, then send user data
            connect_fd = connect_tmp_fd;
        }
        
REPEAT_SEND: // start to send data
        //message->viewMessageHead();
        //message->viewBodyHead();
        result = message->serializeMessage(&send_data, &send_len);
        if(0 != result)
            goto REPEAT_SEND;
        m_comm_base.send(connect_fd, send_data, send_len);
        message->releaseSerializeMessage(send_data);
        send_data = NULL;

FREE_MEMORY:
        message->releaseBodyData();
        delete (message);
        free(worker);
        worker = NULL;
    }
    
    K_INFO("RPC : send thread exit.\n");
    
    pthread_exit(NULL);
}

unsigned int RPCCore::getFrameID(void)
{
    return m_frame_id++;
}

int RPCCore::sendLinkMessage(void *fdp)
{
    int result = -1;
    unsigned int frame;
    RPCProxy proxy_impl;
    size_t link_len = 0;
    void *link_data = NULL;
    Message *request = NULL;
    Message *response = NULL;
    struct timespec tp = {0, 0};

    request = new Message();
    if(NULL == request)
    {
        K_ERROR("RPC : new link message memory failed!\n");
        return -1;
    }

    frame = getFrameID();
    request->initLinkRequestMessage(&tp, frame, RPCSUCCESS);
    request->setSender(m_process);
    request->mallocBodyData(NULL, 0);
    request->updateBodySize();
    //request->viewMessageHead();
    //request->viewBodyHead();
    
REPEAT_SEND:
    result = request->serializeMessage(&link_data, &link_len);
    if(0 != result)
        goto REPEAT_SEND;
    m_comm_base.send(fdp, link_data, link_len);
    request->releaseSerializeMessage(link_data);
    request->releaseBodyData();
    delete (request);
    
    result = proxy_impl.init();
    if(0 != result)
    {
        K_ERROR("RPC : init proxy service failed!\n");
        return -1;
    }
    m_proxy_hash.insert(frame, (void *)&proxy_impl);
    result = proxy_impl.wait(m_comm_tv);
    m_proxy_hash.remove(frame);
    response = (Message *)proxy_impl.getResponseMsg();
    proxy_impl.destroy();
    
    if((0 == result) && response)
        m_connect_hash.insert(response->getSender(), fdp);
    
    if(response)
    {
        response->releaseBodyData();
        delete (response);
    }
    
    return 0;
}

int RPCCore::recvLinkMessage(void *fdp, void *msg)
{
    struct timespec tp;
    Message *response = NULL;
    Message *request = (Message *)msg;
    struct WorkerEntry *worker = NULL;
    
    response = new Message();
    if(NULL == response)
    {
        K_ERROR("RPC : new message memory failed!\n");
        return -1;
    }

    /* init message head */
    tp = request->getTimeoutTP();
    response->initApplyResponseMessage(&tp, request->getMessageID(), RPCSUCCESS);
    /* init body head */
    response->setSender(m_process);
    response->setRecver(request->getSender());
    /* init body data */
    response->mallocBodyData(NULL, 0);
    response->updateBodySize();

    worker = (struct WorkerEntry *)malloc(sizeof(struct WorkerEntry));
    if(NULL == worker)
    {
        K_ERROR("RPC : malloc WorkerEntry struct failed!\n");
        response->releaseBodyData();
        delete (response);
        return -1;
    }
    worker->message = (void *)response;
    addSendWorker((void *)worker);
    
    return 0;
}

int RPCCore::errorACKMessage(void *fdp, void *msg)
{
    struct timespec tp;
    Message *response = NULL;
    Message *request = (Message *)msg;
    struct WorkerEntry *worker = NULL;
    
    response = new Message();
    if(NULL == response)
    {
        K_ERROR("RPC : new message memory failed!\n");
        return -1;
    }

    /* init message head */
    tp = request->getTimeoutTP();
    response->initApplyResponseMessage(&tp, request->getMessageID(), RPCNOSPECIFYSERVICE);
    /* init body head */
    response->setBodyHead(m_process, request->getSender(), request->getModule(), request->getFunction());
    /* init body data */
    response->mallocBodyData(NULL, 0);
    response->updateBodySize();

    worker = (struct WorkerEntry *)malloc(sizeof(struct WorkerEntry));
    if(NULL == worker)
    {
        K_ERROR("RPC : malloc WorkerEntry struct failed!\n");
        response->releaseBodyData();
        delete (response);
        return -1;
    }
    worker->message = (void *)response;
    addSendWorker((void *)worker);

    return 0;
}

void RPCCore::releaseRPCMessage(void *arg)
{
    Message *message = (Message *)arg;
    if(message)
    {
        message->releaseBodyData();
        delete (message);
    }
}

void RPCCore::signalHandler(int signo)
{
    int size,i;
    char **strings;
    void *array[150];

    switch (signo)
    {
        case SIGINT:
        case SIGTERM:
            /* release system resource, and exit(0) */
            K_WARN("\n\nRPC : receive exit signal.\n");
            m_run_state = false;
            break;

        case SIGALRM:
            break;

        case SIGSEGV:
            K_ERROR("RPC : Segment fault:\n");
            size = backtrace(array,150);
            strings = backtrace_symbols(array,size);
            for(i = 0;i < size;i++)
                K_ERROR(" %d deep : %s\n",i,strings[i]);
            free(strings);
            K_ERROR("RPC : exited!\n");
            exit(-1);
            break;

        default:
            break;
    }
}

int RPCCore::analyseReceiveData(void *fdp, const void *data, size_t len)
{
    int result = -1;
    void *fdp_old = NULL;
    Message *message = NULL;
    ServerFunction func_handler = NULL;
    unsigned char *ptr = (unsigned char *)data;
    
REPEAT_ANALYSE:
    message = new Message();
    if(NULL == message)
    {
        K_ERROR("RPC : new message memory failed on receive!\n");
        goto REPEAT_ANALYSE;
    }
    message->getMessageHeadFromData((void *)ptr);
    ptr += MESSAGE_HEAD_SIZE;
    message->getBodyHead((void *)ptr);
    ptr += message->getBodyHeadSize();
    //message->viewMessageHead();
    //message->viewBodyHead();
    result = message->mallocBodyData((void *)ptr, len - MESSAGE_HEAD_SIZE - message->getBodyHeadSize());
    if(0 !=result)
    {
        delete (message);
        return -1;
    }
    switch(message->getMessageType())
    {
        case MT_LINK_PK:
            if(message->checkResponseStatus())
            {
                RPCProxy *proxy_impl = (RPCProxy *)m_proxy_hash.find(message->getMessageID());
                if(NULL == proxy_impl)
                {
                    message->releaseBodyData();
                    delete (message);
                    return -1;
                }
                proxy_impl->setResponseMsg(message);
                proxy_impl->wakeup();
            }
            else
            {
                fdp_old = m_connect_hash.find(message->getSender());
                if(fdp_old)
                {
                    m_connect_hash.remove(message->getSender());
                    m_comm_base.disconnect(fdp_old);
                    m_connect_list.remove(fdp_old);
                }
                m_connect_hash.insert(message->getSender(), fdp);
                recvLinkMessage(fdp, (void *)message);
                message->releaseBodyData();
                delete (message);
            }
            break;

        case MT_BEAT_PK:
            message->releaseBodyData();
            delete (message);
            break;

        case MT_APPLY_PK:
            if(message->checkResponseStatus())
            {
                RPCProxy *proxy_impl = (RPCProxy *)m_proxy_hash.find(message->getMessageID());
                if(NULL == proxy_impl)
                {
                    message->releaseBodyData();
                    delete (message);
                    return -1;
                }
                proxy_impl->setResponseMsg(message);
                proxy_impl->wakeup();
            }
            else
            {
                func_handler = (ServerFunction)m_func_hash.find(message->getFunction());
                if(NULL == func_handler)
                {
                    K_ERROR("RPC : %s module does't has %s function, please check!\n", message->getModule().c_str(), message->getFunction().c_str());
                    errorACKMessage(fdp, (void *)message);
                    message->releaseBodyData();
                    delete (message);
                    return -1;
                }
                result = m_threadpool->addWork(LowPriority, func_handler, (void *)message, releaseRPCMessage);
                if(0 != result)
                {
                    message->releaseBodyData();
                    delete (message);
                    return -1;
                }
            }
            break;

        default:
            message->releaseBodyData();
            delete (message);
            break;
    }
    
    return 0;
    
#ifdef ANALYSERECEIVE
    int result = -1;
    static Message *message = NULL;
    static size_t recv_length = 0;
    static AnalysePackage ap_state = AP_INIT;
    static unsigned char tmp_data[MESSAGE_HEAD_SIZE + 2];

    // the all data received
    recv_length += len;

REPEAT_ANALYSE:
    switch(ap_state)
    {
        case AP_INIT: // until receive a head data
            // abandon data according to MESSAGE_MAGIC_NUM
            //if(MESSAGE_MAGIC_NUM != m_message_head.magic)
            //    ;
            if(recv_length < MESSAGE_HEAD_SIZE)
                memcpy((void *)&tmp_data[recv_length - len], data, len);
            else
            {
                if(recv_length == len)
                    memcpy((void *)tmp_data, data, MESSAGE_HEAD_SIZE);
                else
                    memcpy((void *)&tmp_data[recv_length - len], data, (MESSAGE_HEAD_SIZE - (recv_length - len)));
                ap_state = AP_HEAD;
            }
            break;
            
        case AP_HEAD:
            message = new Message();
            if(NULL == message)
            {
                K_ERROR("RPC : new message memory failed on receive!\n");
                goto REPEAT_ANALYSE;
            }
            message->getMessageHeadFromData(tmp_data);
            ap_state = AP_BODY_HEAD;
            break;
            
        case AP_BODY_HEAD:
            result = message->mallocBodyData(message->getBodySize());
            if(0 != result)
                goto REPEAT_ANALYSE;
            break;
            
        case AP_BODY_DATA:
            
            break;
            
        default:
            if(message)
            {
                message->releaseBodyData();
                delete (message);
                message = NULL;
            }
            recv_length = 0;
            ap_state = AP_INIT;
            break;
    }
    
    return 0;
#endif
}

int RPCCore::eventHandler(unsigned int type, void *fd_ptr, void *data, size_t data_len)
{
    switch(type)
    {
        case COMMEventRecv:
            if(data_len)
                analyseReceiveData(fd_ptr, data, data_len);
            break;
            
        case COMMEventSend:
            break;
            
        case COMMEventConnect:
            m_connect_list.insert(fd_ptr);
            break;

        case COMMEventDisconnect:
            m_connect_list.remove(fd_ptr);
            m_connect_hash.remove(fd_ptr);
            break;

        case COMMEventCheck:
            break;
            
        case COMMEventRTimeout:
            break;
            
        case COMMEventSTimeout:
            break;
            
        default:
            break;
    }

    return 0;
}

