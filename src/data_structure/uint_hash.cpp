/* uint_hash.cpp
 * DO NOT EDIT THIS FILE.
 * Date  : 2017-11-09
 * Author: Konishi
 * Email : konishi5202@163.com
 */
#include <stdio.h>

#include "uint_hash.h"

#define K_DEBUG   printf
#define K_INFO    printf
#define K_WARN    printf
#define K_ERROR   printf

pthread_rwlock_t UINTHash::m_rwlock = PTHREAD_RWLOCK_INITIALIZER;

UINTHash::UINTHash()
{
    pthread_rwlock_wrlock(&m_rwlock);
    uint_map.clear();
    pthread_rwlock_unlock(&m_rwlock);
}

UINTHash::~UINTHash()
{
    pthread_rwlock_wrlock(&m_rwlock);
    uint_map.clear();
    pthread_rwlock_unlock(&m_rwlock);
}

void UINTHash::print(void)
{
    pthread_rwlock_rdlock(&m_rwlock);
    K_INFO("Hash Table:\n");
    for(it = uint_map.begin(); it != uint_map.end(); it++)
        K_INFO("%d => %p\n", it->first, it->second);
    pthread_rwlock_unlock(&m_rwlock);
}

int UINTHash::size(void)
{
    int size = 0;
    pthread_rwlock_rdlock(&m_rwlock);
    size = uint_map.size();
    pthread_rwlock_unlock(&m_rwlock);
    return size;
}

void UINTHash::clear(void)
{
    pthread_rwlock_wrlock(&m_rwlock);
    uint_map.clear();
    pthread_rwlock_unlock(&m_rwlock);
}

bool UINTHash::empty(void)
{
    bool empty = false;
    pthread_rwlock_rdlock(&m_rwlock);
    empty = uint_map.empty();
    pthread_rwlock_unlock(&m_rwlock);
    return empty;
}

void *UINTHash::find(unsigned int key)
{
    void *result = NULL;
    pthread_rwlock_rdlock(&m_rwlock);
    it = uint_map.find(key);
    result = (it == uint_map.end()) ? NULL : it->second;
    pthread_rwlock_unlock(&m_rwlock);
    return result;
}

int UINTHash::remove(unsigned int key)
{
    pthread_rwlock_wrlock(&m_rwlock);
    it = uint_map.find(key);
    if(it != uint_map.end())
        uint_map.erase(it);
    pthread_rwlock_unlock(&m_rwlock);
    return 0;
}

void UINTHash::remove(void *value)
{
    pthread_rwlock_wrlock(&m_rwlock);
    for(it = uint_map.begin(); it != uint_map.end(); it++)
    {
        if(value == it->second)
        {
            uint_map.erase(it->first);
            break;
        }
    }
    pthread_rwlock_unlock(&m_rwlock);
}

int UINTHash::insert(unsigned int key, void *value)
{
    int result = 0;
    pthread_rwlock_wrlock(&m_rwlock);
    it = uint_map.find(key);
    if(it != uint_map.end()) // exsit
        result = 1;
    else
        uint_map[key] = value;
//        uint_map.insert(std::pair<int, void *>(key, value));
    pthread_rwlock_unlock(&m_rwlock);
    return result;
}

int UINTHash::change(unsigned int key, void *value)
{
    int result = 0;
    pthread_rwlock_wrlock(&m_rwlock);
    it = uint_map.find(key);
    if(it == uint_map.end()) // not exsit
        result = -1;
    else
        uint_map[key] = value;
    pthread_rwlock_unlock(&m_rwlock);
    return result;
}

