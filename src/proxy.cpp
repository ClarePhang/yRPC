/* proxy.cpp
 * DO NOT EDIT THIS FILE.
 * Date  : 2017-11-20
 * Author: Konishi
 * Email : konishi5202@163.com
 */
#include <pthread.h>
#include "proxy.h"

#define tp_tvaddtp(tv, tp, ttp)					\
	do {								\
		(ttp)->tv_sec = (tv)->tv_sec + (tp)->tv_sec;		\
		(ttp)->tv_nsec = ((tv)->tv_usec * 1000)+ (tp)->tv_nsec;       \
		if ((ttp)->tv_nsec >= 1000000000) {			\
			(ttp)->tv_sec++;				\
			(ttp)->tv_nsec -= 1000000000;			\
		}							\
	} while (0)

Proxy::Proxy()
{
    request = NULL;
    response = NULL;
}

Proxy::~Proxy()
{
    request = NULL;
    response = NULL;
}

int Proxy::init(void)
{
    if(pthread_attr_init(&attr) != 0)
        return -1;

    if(pthread_cond_init(&cond, NULL) != 0)
    {
        pthread_attr_destroy(&attr);
        return -1;
    }
    
    if(pthread_mutex_init(&mutex, NULL) != 0)
    {
        pthread_attr_destroy(&attr);
        pthread_cond_destroy(&cond);
        return -1;
    }
    return 0;
}

void Proxy::destroy(void)
{
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
    pthread_attr_destroy(&attr);
}

int Proxy::wait(struct timeval &tv)
{
    int ret = -1;
    
    struct timespec tp;
    pthread_mutex_lock(&mutex);
    if((tv.tv_sec == 0) && (tv.tv_usec == 0))
        ret = pthread_cond_wait(&cond, &mutex);
    else
    {
        clock_gettime(CLOCK_REALTIME,&tp);
        tp_tvaddtp(&tv, &tp, &tp);
        ret = pthread_cond_timedwait(&cond, &mutex, &tp);
    }
    pthread_mutex_unlock(&mutex);

    return ret;
}

void Proxy::wakeup(void)
{
    pthread_mutex_lock(&mutex);
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&mutex);
}

void Proxy::setRequestMsg(void *msg)
{
    request = msg;
}

void *Proxy::getRequestMsg(void)
{
    return request;
}

void Proxy::setResponseMsg(void *msg)
{
    response = msg;
}

void *Proxy::getResponseMsg(void)
{
    return response;
}

